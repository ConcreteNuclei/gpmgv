;===============================================================================
;+
; Copyright Â© 2013, United States Government as represented by the
; Administrator for The National Aeronautics and Space Administration.
; All Rights Reserved.
;
; plot_dpr_xsection_zbuf_zczm.pro    Morris/SAIC/GPM_GV    Sep 2015
;
; DESCRIPTION
; -----------
; Takes a full arrays of GPM DPR 3-D raw and corrected reflectivity, parameters
; specifying the scan line and start/end rays in the product for which a cross
; section of data is to be plotted, and bright band mean height and an optional
; plot title, and generates a pair of vertical cross sections of full-resolution
; DPR reflectivity in the form of a two-panel Z-buffer image and an associated
; color table.  The top plot uses the raw Z and the bottom uses the attenuation
; corrected Z.  Each is displayed with the discrete color table of the PPI plots
; with a 3 dBZ color binning.  A parallax correction for the scan angle of
; the DPR is applied to the height of each 125- or 250-m DPR gate.
;
; The plots use a default value of 320 pixels in height for each of the two
; cross section plots, to match the dimensions of the plots of geometry-matched
; DPR and GR data generated by the 'plot_geo_match_xsection' procedure.  The
; width of the cross-section plots, and of each plotted ray, varies according
; to the number of rays to be plotted in the normal mode of selecting one DPR
; scan.  If the STARTEND2SHOW parameter is specified, the window is sized for
; a fixed number of scans to a limit of all 49/25/24 rays in the scan, a fixed
; width is assigned for each ray and the window, and rays are plotted in fixed
; locations as defined by their ray number in the scan.
;
; If a flagEcho array is provided then gates flagged as clutter will have a dBZ
; value of 55 assigned to help them stand out uniquely.
;
; Returns the cross section image Z-buffer, color definitions, and image x- and
; y-dimensions in a structure.
;
; PARAMETERS
; ----------
; scanNumpr  - DPR-product-relative number of the DPR scan whose data are to be
;              plotted as a vertical cross section.  Zero-based array index.
;
; raystartpr - Starting ray of the scan to plot in the cross section.  Zero-
;              based array index into the full data array.
;
; rayendpr   - As above, but ending ray to plot in the cross section.
;
; z_data     - Full array of (assumed) DPR 3-D corrected reflectivity data.
;
; zm_data    - Full array of DPR 3-D measured reflectivity data.
;
; meanbb     - Mean height of the bright band, in km.
;
; scale      - Scale factor to be applied to convert z_data to dBZ units.
;
; cos_inc_angle_all  - Array of cos() of DPR ray zenith angle.
;
; gate_space     - Spacing in meters of DPR gates/bins, either 250m or 125m.
;
; surfbin        - Array of bin number of the at-surface DPR bin (on the
;                  ellipsoid, i.e., MSL).  Read directly from the DPR data file.
;
; clutterfreebin - Array of bin number of the lowest DPR bin that is not in
;                  the ground cluuter region.  Read directly from the DPR data
;                  file.
;
; BB_hgt_in  - Array of DPR ray bright band height, in meters.  Read directly
;              from the DPR data file.
;
; caseTitle  - (Optional) title to be written into the cross section images.
;
; BBbyray    - Optional binary parameter.  If set to ON, then a marker will be
;              plotted at the BB height of each individual ray on the
;              full-resolution DPR data cross sections.
;
; bbwidth    - Height (km) above/below the mean bright band height within
;              which a sample touching (above) [below] this layer is
;              considered to be within (above) [below] the BB.  If not
;              specified, takes on the default value (0.750) defined in
;              fprep_geo_match_profiles().
;
; flagEcho   - 2A-DPR/Ka/Ku flag variable to identify clutter gates in z_data
;              array.  Values of 16b or greater indicate clutter of some type.
;              Byte array.
;
; prpl_hz    - Optional binary parameter.  If set to ON, then gates of negative
;              attenuation correction (zm_data>z_data) will be plotted in bluish
;              purple (the top color in the color bar, normally >57 dBZ), hiding
;              their actual reflectivity color assignments.
;
; startend2show - Optional parameter, a 2-element array listing the minimum
;                 starting and maximum ending ray numbers to be plotted in the
;                 cross section, over all PR scans in the data set.  Zero-based,
;                 values range from 0 to 48 (NS scan), 24 (MS scan) or 23 (HS
;                 scan) (computed internally).  If provided, the ray widths and
;                 plotted ray locations in the cross sections are set up
;                 according to the number of rays between startend2show[0] and
;                 startend2show[1]. In essence, the cross-section domain is set
;                 up in a fixed manner based on the this number of rays, where
;                 the plotted locations of each ray depends on the values of
;                 startend2show, raystartpr, and rayendpr. 
;
; label_by_raynum - Optional binary parameter.  If set to OFF, then the edges of
;                   the x-sections are labeled with A and B, to orient the
;                   cross section with regard to the line drawn on the PPIs
;                   showing the location of the PR scan selected for display.
;                   IF set to ON, then the values of PR ray number contained in
;                   raystartpr and rayendpr are used to label the L/R edges of
;                   the x-section.
;
; sourceLabelIn  - Alternative string to identify the source of the DPR data
;                  being plotted, e.g. 'Ku/NS'.  Defaults to 'DPR' if not given.
;
; HISTORY
; -------
; 07/2013  Morris/GPM GV/SAIC  
; - Created from plot_pr_xsection_zbuf.pro.
; -3/16/15  Morris/GPM GV/SAIC
; - Swapped plotted positions of caseTitle and data source/type annotations.
;
;
; EMAIL QUESTIONS OR COMMENTS TO:
;       <Bob Morris> kenneth.r.morris@nasa.gov
;       <Matt Schwaller> mathew.r.schwaller@nasa.gov
;-
;===============================================================================

function plot_dpr_xsection_zbuf_zczm, scanNumpr, raystartpr, rayendpr, z_data_in, $
                                 zm_data_in, meanbb, scale, cos_inc_angle_all, $
                                 gate_space, surfbin, clutterfreebin, BB_hgt_in, $
                                 TITLE=caseTitle, BBBYRAY=BBbyray, $
                                 BBWIDTH=bbwidth, STARTEND2SHOW=startend2show, $
                                 FLAG_ECHO=flagEchoIn, PRPL_HZ=prpl_hz, $
                                 LABEL_BY_RAYNUM=label_by_raynum, $
                                 SOURCELABEL=sourceLabelIn, $
                                 SHOW_SFC_CLUTR=show_sfc_clutr

; "Include" file for PR-product-specific parameters (i.e., RAYSPERSCAN):
@dpr_params.inc

IF ( N_ELEMENTS(bbwidth) NE 1 ) THEN bbwidth=0.750
IF bbwidth GT 2.0 OR bbwidth LT 0.2 THEN BEGIN
   print, "In plot_dpr_xsection_zbuf, overriding outlier bbwidth value:", $
           bbwidth, " km to 0.750 km"
   bbwidth=0.750
ENDIF

IF N_ELEMENTS( sourceLabelIn ) EQ 1 THEN sourceLabel = sourceLabelIn $
ELSE sourceLabel = 'DPR'

; don't modify input array, make local copy
z_data=z_data_in
zm_data=zm_data_in

IF N_ELEMENTS( flagEchoIn ) NE 0 THEN BEGIN
;   save, scanNumpr, raystartpr, rayendpr, z_data, flagEchoIn, clutterfreebin, file='/tmp/savedVars.sav'
   sstatus = filter_clutter( scanNumpr, raystartpr, rayendpr, z_data, $
                             flagEchoIn, clutterfreebin )
   setClutter = 1
   clutterKu = flagEchoIn AND 80B
   idx_clutter = WHERE( clutterKu NE 0B, countclutter )
   IF countclutter GT 0 THEN BEGIN
      ; set the Z values identified as clutter to 55.0 dBZ
;      z_data[idx_clutter] = 55.0
;      zm_data[idx_clutter] = 55.0
   ENDIF
ENDIF ELSE setClutter = 0

hide_sfc_clutr = 1 - KEYWORD_SET(show_sfc_clutr)

; plot gates on the cross section at a vertical scale of 16 pixels/1000m,
; which comes out to 4 pixels for 250m, or 2 pixels for 125 m (Ka/HS only)
bindepth = gate_space/62
;print, "bindepth, gate_space: ", bindepth, gate_space
 
; grab the ray angle trig variables for parallax (only cos() used here):
cos_inc_angle = cos_inc_angle_all[raystartpr:rayendpr, scanNumpr]

; from the DPR Z array, extract the rays to be plotted for scan = scanNumpr
xsect2d = z_data[*, raystartpr:rayendpr, scanNumpr]  ;DPR order is bin,ray,scan
xsect2dm = zm_data[*, raystartpr:rayendpr, scanNumpr]
idxclutter = WHERE( xsect2d LT 0.0, nclutr )
IF ( nclutr GT 0 ) THEN xsect2d[idxclutter] = 0.0

idxclutter = WHERE( xsect2dm LT 0.0, nclutr )
IF ( nclutr GT 0 ) THEN xsect2dm[idxclutter] = 0.0

; tag locations where Zm > Zc if PRPL_HZ is set
idxbackwards = WHERE( xsect2d LT xsect2dm and xsect2d GE 18.0, nbackwds)
IF nbackwds GT 0 THEN BEGIN
   PRINT, ''
   PRINT, "Mean/Num negative attenuation: ", $
          MEAN(xsect2dm[idxbackwards]-xsect2d[idxbackwards]), ', ', nbackwds
   PRINT, ''
   IF KEYWORD_SET(prpl_hz) THEN BEGIN
      xsect2d[idxbackwards] = 58.
      xsect2dm[idxbackwards] = 58.
   ENDIF
ENDIF

; from the same array, find the number of rays per scan (2nd dimension)
sz_z = SIZE(z_data, /DIMENSIONS)
nraysper = sz_z[1]                            ; use later in error check
str_nray = STRING(nraysper-1, FORMAT='(I0)')  ; use later in error message
;print, 'LASTRAY=', str_nray

xsect2d = xsect2d/scale  ; unscale PR dbz
xsect2dm = xsect2dm/scale
; get rid of dimension(s) of size 1, and flip vertically
; to account for bin order (surface bin ~= 170)
trimmed = REFORM( xsect2d )
trimmedm = REFORM( xsect2dm )
ts = SIZE(trimmed)

; how many rays are we plotting this time?
IF ts[0] EQ 2 THEN BEGIN
  ; 2 or more rays to plot, have 2-D xsect2d array
   nrays = ts[2]
   nbins = ts[1]
ENDIF ELSE BEGIN
  ; only one ray to plot, have 1-D xsect2d array
   nrays = 1
   nbins = ts[1]
ENDELSE

; blank out the clutter bins, if information provided and
; SHOW_SFC_CLUTR is not set
IF (N_ELEMENTS(clutterfreebin) GT 0 AND hide_sfc_clutr) THEN BEGIN
   clutterbinnum = clutterfreebin[raystartpr:rayendpr, scanNumpr]
   for k = 0, nrays-1 DO BEGIN
      IF (clutterbinnum[k]) LE (nbins-1) THEN BEGIN
         trimmed[clutterbinnum[k]:nbins-1,k] = 0.0
         trimmedm[clutterbinnum[k]:nbins-1,k] = 0.0
      ENDIF
   endfor
ENDIF

; flip Z array vertically to put bins in ascending height order
xsect2d = REVERSE( trimmed, 1 )
xsect2dm = REVERSE( trimmedm, 1 )

IF (N_ELEMENTS(surfBin) GT 0) THEN BEGIN
  ; compute surface gate number based on gate 0 at top
   sfcbinnum = surfbin[raystartpr:rayendpr, scanNumpr]
  ; adjust surface gate number for flipped Z array
   sfcbinnum = (nbins-sfcbinnum)>0
ENDIF

IF N_ELEMENTS( BB_hgt_in ) GT 0 THEN BEGIN
   BB_hgt = BB_hgt_in[raystartpr:rayendpr, scanNumpr]/1000.  ; scale m to km
   idxhavebb = WHERE ( BB_hgt GT 0.0, counthavebb )
   IF (counthavebb GT 0) THEN BEGIN
      ; scale km to image pixel y values
      BB_hgt[idxhavebb] = BB_hgt[idxhavebb]*16.
      have_bb=1
   ENDIF ELSE BEGIN
      BB_hgt[*] = BB_MISSING
      have_bb=0
   ENDELSE
ENDIF ELSE BEGIN
   BB_hgt = FLOAT(surfbin)
   BB_hgt[*] = BB_MISSING
   have_bb=0
ENDELSE

;==============================================================================
; SET UP THE PLOT BOUNDS/DOMAIN

ysize = 320  ; 0-20km at 16 pixels/km

; set up the xsize and plotted width of each ray based on the domain to be used:
; -- figure out whether to configure x-sections' ray width based on the range
;    of rays defined in startend2show, or on the number of PR/GR overlap rays
;    in the current scan
CASE N_ELEMENTS(startend2show) OF
      0 : BEGIN
           ; configure to the number of rays in current scan (legacy plot)
            doFixed = 0
          END
      2 : BEGIN
           ; error check the values in startend2show
            IF startend2show[0] GT startend2show[1] THEN BEGIN
               doFixed = 0
               print, "In plot_pr_xsection, illegal value for STARTEND2SHOW ", $
                  "must be INTARR(2), with startend2show[0] LE startend2show[1]"
               print, "startend2show: ", startend2show
               goto, errorExit
            ENDIF ELSE BEGIN
               IF startend2show[0] LT 0 $
               OR startend2show[1] GT (nraysper-1) THEN BEGIN
                  doFixed = 0
                  print, "In plot_pr_xsection, illegal value for ", $
                     "STARTEND2SHOW, must have startend2show[0] GE 0, and ", $
                     "startend2show[1] LE ", str_nray
                  print, "startend2show: ", startend2show
                  goto, errorExit
               ENDIF
            ENDELSE
           ; check that raystartpr, rayendpr values are between startend2show's
            IF (startend2show[0] LE raystartpr) AND $
               (startend2show[1] GE rayendpr) THEN BEGIN
               doFixed = 1
            ENDIF ELSE BEGIN
               doFixed = 0
               print, "In plot_pr_xsection, values for raystartpr, rayendpr ", $
                      "exceed plot limits defined in startend2show."
               print, "startend2show: ", startend2show
               print, "raystartpr, rayendpr: ", raystartpr, rayendpr
               goto, errorExit
            ENDELSE
          END
   ELSE : BEGIN
            print, "In plot_pr_xsection, illegal value for STARTEND2SHOW, ", $
                   "must be either INTARR(2) or undefined.  Disabled option."
            help, startend2show
            doFixed = 0
          END
ENDCASE

IF doFixed THEN BEGIN
   nrayswide = startend2show[1]-startend2show[0]+1
   xsize = (ysize/nrayswide)*nrayswide
   raywidth = xsize/nrayswide
ENDIF ELSE BEGIN
   xsize = (ysize/nrays)*nrays
   raywidth = xsize/nrays
ENDELSE

; xoff: Where is the first ray plotted on the x-section window, x-wise?
IF doFixed THEN xoff = raywidth*(raystartpr-startend2show[0]) $
           ELSE xoff = 0  ; non-fixed-size window, legacy appearance

xwinsize = xsize + 50
ywinsize = ysize*2
image2render = BYTARR(xwinsize,ysize)  ; hold x-sect image plus color bar

; figure out how to label the ends of the cross section based on LABEL_BY_RAYNUM
IF KEYWORD_SET( label_by_raynum ) THEN BEGIN
   leftlbl=STRING(raystartpr+1, FORMAT='(I0)')
   rightlbl=STRING(rayendpr+1, FORMAT='(I0)')
ENDIF ELSE BEGIN
   leftlbl = 'A'
   rightlbl = 'B'
ENDELSE

;==============================================================================
; SET UP COLOR TABLE AND COLORBAR

; set up the 16-level color table from the PPI as the bottom half of color table
; -- set values 122-127 as white, for labels and such
tvlct, rr,gg,bb,/get
rr[122:127] = 255
gg[122:127] = 255
bb[122:127] = 255
tvlct, rr,gg,bb

nsteps = 17      ; number of colors for our image
ystep = ysize/nsteps
ybarsize = ystep * nsteps
colorbar = BYTARR(15,ybarsize)
colorbar_y = (ysize-ybarsize)/2  ; y position of bottom of colorbar in image
; fill color bar values
FOR i = 0, nsteps-1 DO BEGIN
   colorbar[*,ystep*i:ystep*(i+1)-1] = i
ENDFOR

; put a white boundary around color bar
colorbar[*,0]=122 & colorbar[*,ybarsize-1]=122
colorbar[0,*]=122 & colorbar[14,*]=122

; burn color bar into image
image2render[xsize+10:xsize+10+15-1,colorbar_y:colorbar_y+ybarsize-1] = colorbar


;==============================================================================
; build the x-section as an image array --
; see geo_match/loadcolortable.pro for the dbz mapping to colors used below

maxprval = MAX(xsect2d[WHERE(xsect2d LT 55.)])
maxprstr = STRING( maxprval, FORMAT='(f0.1)' )

xsectimg = BYTARR(xsize, ysize)
xsectimg[*,*] = 0b ;2B

for k = 0, nrays-1 DO BEGIN
   ; first, start at the at-surface bin, if available
   IF (N_ELEMENTS(surfBin) GT 0) THEN binstart=sfcbinnum[k] ELSE binstart=0
   for l = 0, nbins - 1 DO BEGIN
     ; correct gate top/bottom height for beam parallax and fill image pixels
      xstart=k*raywidth + xoff
      xend = xstart + raywidth - 1
      ystart = FIX( l*bindepth*cos_inc_angle[k] ) < 319
      yend = FIX( (l+1)*bindepth*cos_inc_angle[k] ) < 319
      IF (xend LE xstart OR yend LE ystart) THEN BREAK     ; bounds limit met
     ; deal with binstart>0
      bin2get = (l+binstart) < (nbins-1)
     ; handle 2-D vs. 1-D data array
      IF ts[0] EQ 2 THEN $
         xsectimg[xstart:xend,ystart:yend] = $
            BYTE( ( (xsect2d[bin2get,k]-12.0 > 0)/3 +1)  < 128. ) $
      ELSE xsectimg[xstart:xend,ystart:yend] = $
              BYTE( ( (xsect2d[bin2get]-12.0 > 0)/3 +1)  < 128. )
   endfor
endfor

;==============================================================================
; PLOT, LABEL, AND ANNOTATE

SET_PLOT,'Z'
; set up the z-buffer device, and set baseline character size to match up
; to how things would look if plotting directly to 'X' device, as 'Z'
; device has different pixels/cm scaling.  Little fuzzy on this, but it works.
DEVICE, SET_RESOLUTION = [xwinsize,ywinsize], SET_CHARACTER_SIZE=[6,10]

image2render[0,0] = xsectimg
; plot the PPI-colored x section in the top half of the window
TV, image2render, 0

; label the color bar
IF keyword_set(prpl_hz) THEN $
   labels = ['BT','15','18','21','24','27','30','33', $
             '36','39','42','45','48','51','54','A-'] $
ELSE labels = ['BT','15','18','21','24','27','30','33', $
               '36','39','42','45','48','51','54','57']
FOR i = 0, nsteps-1 DO BEGIN
   IF i LT nsteps-1 THEN XYOUTS, xsize+30, ysize+colorbar_y+ystep*(i+1)-4, $
                                 labels[i], COLOR=122, /DEVICE
ENDFOR

; get bright band level
bb_y = FIX(meanbb * 16.0)  ; assumes 4 pixels/gate, gate is 0.25 km deep
; assume BB is from +bbwidth km to -bbwidth km of meanbb, and compute
; upper/lower y-bounds
bb_y_upr = FIX( (meanbb+bbwidth) *16.0 )
bb_y_lwr = FIX( (meanbb-bbwidth) * 16.0 )
bbstr = STRING(meanbb, FORMAT='(f0.1)')

; plot bright band lines: middle, upper bound, lower bound
IF ( KEYWORD_SET(BBbyray) AND have_bb EQ 1 ) THEN BEGIN
   ; plot the ray-specific bright band heights
   for k = 0, nrays-1 DO BEGIN
      xstart=k*raywidth + xoff
      xend = xstart + raywidth -1
      IF (BB_hgt[k] GT 0) THEN $
         PLOTS, [xstart,xend], [BB_hgt[k]+ysize,BB_hgt[k]+ysize], /DEVICE, $
                COLOR=0, THICK=2
   endfor
ENDIF
PLOTS, [0,xsize-1], [bb_y+ysize,bb_y+ysize], /DEVICE,COLOR=0,THICK=2,LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr+ysize,bb_y_upr+ysize], /DEVICE,COLOR=0,LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr+ysize,bb_y_lwr+ysize], /DEVICE,COLOR=0,LINESTYLE=1

yoff = 0
IF N_ELEMENTS( caseTitle ) EQ 1 THEN BEGIN
   yoff = 15
   XYOUTS, 15, ysize+ysize-20-yoff, COLOR=122, caseTitle, /DEVICE
ENDIF

yoffleft=0 & yoffright=0  ; vertical offsets to be reset if labels overlap

IF doFixed THEN BEGIN
  ; compute position of ray labels, relative to where the rays are plotted,
  ; dealing with window bounds
   xlblposright = $
      (((rayendpr-startend2show[0])*raywidth + raywidth/2) < (xsize-18)) > 6
   xlblposleft = ((raystartpr-startend2show[0])*raywidth > 6) < (xsize-18)
  ; deal with potential label overlaps
  IF xlblposright LE (xlblposleft+20) THEN BEGIN
      IF raystartpr GT 25 THEN BEGIN
         yoffleft = 15
         xlblposleft = xlblposleft < (xlblposright-6)
      ENDIF ELSE BEGIN
         xlblposright = xlblposright > (xlblposleft+6)
         yoffright = 15
      ENDELSE
   ENDIF
ENDIF ELSE BEGIN
   xlblposright=xsize-18
   xlblposleft=8
ENDELSE

; plot endpoint labels on upper x-sect panel, shadowed for readability,
; light over dark
XYOUTS, xlblposleft+1, ysize+10+yoffleft, COLOR=0, leftlbl, /DEVICE, $
        CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright+1, ysize+10+yoffright, COLOR=0, rightlbl, /DEVICE, $
        CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposleft, ysize+11+yoffleft, COLOR=122, leftlbl, /DEVICE, $
        CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright, ysize+11+yoffright, COLOR=122, rightlbl, /DEVICE, $
        CHARSIZE=1.5, CHARTHICK=2

XYOUTS, 15, ysize+(ysize-20), COLOR=122, $
        'Original '+sourceLabel+' Zc gates', /DEVICE
XYOUTS, 15, ysize+(ysize-35)-yoff, COLOR=122, '(3 dBZ steps)', /DEVICE
XYOUTS, 15, ysize+(ysize-50)-yoff, COLOR=122, $
   'Max = '+maxprstr+' dBZ,  Mean Bright Band = '+bbstr+' km MSL', /DEVICE

;==============================================================================
; do another x-section, using measured, uncorrected Z
;==============================================================================

image2render[*,*] = 0B

; burn color bar into image
image2render[xsize+10:xsize+10+15-1,colorbar_y:colorbar_y+ybarsize-1] = colorbar

maxprval = MAX(xsect2dm[WHERE(xsect2dm LT 58.)])
maxprstr = STRING( maxprval, FORMAT='(f0.1)' )

;==============================================================================
; load the image array with DPR gate values

xsectimg[*,*] = 0b         ; re-init image array. now using upper half of byte
;for k = 0, nrays-1 DO BEGIN
;   ; first, start at the at-surface bin, if available
;   IF (N_ELEMENTS(surfBin) GT 0) THEN binstart=sfcbinnum[k] ELSE binstart=0
;   for l = 0, nbins - 1 DO BEGIN
;     ; correct gate top/bottom height for beam parallax and fill image pixels
;      xstart=k*raywidth + xoff
;      xend = xstart + raywidth - 1
;      ystart = FIX( l*bindepth*cos_inc_angle[k] ) < 319
;      yend = FIX( (l+1)*bindepth*cos_inc_angle[k] ) < 319
;if xend LE xstart OR yend LE ystart then break
;     ; Every 1 dBZ in reflectivity increments by colorStepPerdbz image counts,
;     ; starting from a bottom cutoff of 15.0 dBZ at image count of 129.
;     ; Round off the dbz value and look up the assigned image color.
;     ; -- deal with binstart>0
;      bin2get = (l+binstart) < (nbins-1)
;     ; -- handle 2-D vs. 1-D data array
;      IF ts[0] EQ 2 THEN $
;         coloridx4gate=(FIX(xsect2d[bin2get,k]-(zminonbar-1)) > 0) < zrange $
;      ELSE coloridx4gate=(FIX(xsect2d[bin2get]-(zminonbar-1)) > 0) < zrange
;      xsectimg[xstart:xend,ystart:yend] = color4dbz[coloridx4gate]
;   endfor
;endfor

for k = 0, nrays-1 DO BEGIN
   ; first, start at the at-surface bin, if available
   IF (N_ELEMENTS(surfBin) GT 0) THEN binstart=sfcbinnum[k] ELSE binstart=0
   for l = 0, nbins - 1 DO BEGIN
     ; correct gate top/bottom height for beam parallax and fill image pixels
      xstart=k*raywidth + xoff
      xend = xstart + raywidth - 1
      ystart = FIX( l*bindepth*cos_inc_angle[k] ) < 319
      yend = FIX( (l+1)*bindepth*cos_inc_angle[k] ) < 319
      IF (xend LE xstart OR yend LE ystart) THEN BREAK     ; bounds limit met
     ; deal with binstart>0
      bin2get = (l+binstart) < (nbins-1)
     ; handle 2-D vs. 1-D data array
      IF ts[0] EQ 2 THEN $
         xsectimg[xstart:xend,ystart:yend] = $
            BYTE( ( (xsect2dm[bin2get,k]-12.0 > 0)/3 +1)  < 128. ) $
      ELSE xsectimg[xstart:xend,ystart:yend] = $
              BYTE( ( (xsect2dm[bin2get]-12.0 > 0)/3 +1)  < 128. )
   endfor
endfor

image2render[0,0] = xsectimg

;==============================================================================
; PLOT, LABEL, AND ANNOTATE

; insert a separator at the top of the lower image
image2render[*,ysize-2:ysize-1] = 122B
TV, image2render, 1

; plot endpoint labels on lower x-sect panel, shadowed for readability,
; light over dark
XYOUTS, xlblposleft+1, 10+yoffleft, COLOR=0, leftlbl, /DEVICE, $
        CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright+1, 10+yoffright, COLOR=0, rightlbl, /DEVICE, $
        CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposleft, 11+yoffleft, COLOR=122, leftlbl, /DEVICE, $
        CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright, 11+yoffright, COLOR=122, rightlbl, /DEVICE, $
        CHARSIZE=1.5, CHARTHICK=2

IF N_ELEMENTS( caseTitle ) EQ 1 THEN $
   XYOUTS, 15, ysize-20-yoff, COLOR=122, caseTitle, /DEVICE
XYOUTS, 15, (ysize-20), COLOR=122, /DEVICE, $
        'Original '+sourceLabel+' Zm gates' ;, $
        ;, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 15, (ysize-35)-yoff, COLOR=122, /DEVICE, $
        'Max = '+maxprstr+' dBZ,  Mean Bright Band = '+bbstr+' km MSL'

; plot bright band lines: middle, upper bound, lower bound
IF ( KEYWORD_SET(BBbyray) AND have_bb EQ 1 ) THEN BEGIN
   ; plot the ray-specific bright band heights
   for k = 0, nrays-1 DO BEGIN
      xstart=k*raywidth + xoff
      xend = xstart + raywidth -1
      IF (BB_hgt[k] GT 0) THEN PLOTS, [xstart,xend], [BB_hgt[k],BB_hgt[k]], $
                                     /DEVICE, COLOR=122, THICK=2
   endfor
ENDIF
PLOTS, [0,xsize-1], [bb_y,bb_y], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr,bb_y_upr], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr,bb_y_lwr], /DEVICE, COLOR=0, LINESTYLE=1

; label lower image's color bar
;FOR i = 0, nbarsegs-1 DO BEGIN
;   XYOUTS, xsize+30, colorbar_y + ystep*i - 3, labels[i], COLOR=122, /DEVICE
;ENDFOR

; label the color bar
FOR i = 0, nsteps-1 DO BEGIN
   IF i LT nsteps-1 THEN XYOUTS, xsize+30, colorbar_y+ystep*(i+1)-4, $
                                 labels[i], COLOR=122, /DEVICE
ENDFOR

; burn in a vertical scale on either side of the two x-sections
tickcolr = 0
FOR h = 1, 19 DO BEGIN
   xlen = 4
   yh = h*16-1
   IF h mod 5 EQ 0 THEN BEGIN
     ; plot major tick and label it with the height in km
      xlen = 7
      XYOUTS, xlen+6, yh-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", $
              /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh-2, COLOR=122, string(h, FORMAT='(I0)')+" km", $
              /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+6, yh+ysize-3, string(h, FORMAT='(I0)')+" km", $
              COLOR=tickcolr, /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh+ysize-2, COLOR=122, string(h, FORMAT='(I0)')+" km", $
              /DEVICE, CHARSIZE=0.75
   ENDIF
   ; plot in black on right
   PLOTS, [xsize-xlen-1,xsize-1], [yh,yh], /DEVICE, COLOR=tickcolr
   PLOTS, [xsize-xlen-1,xsize-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=tickcolr
   ; plot in white on right
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=122 ;COLOR=122
   ; add a shadow to white plot
   PLOTS, [0,xlen], [yh-1,yh-1], /DEVICE, COLOR= tickcolr
   ; upper panel, left
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=122
  ; add a shadow
   PLOTS, [0,xlen], [yh+ysize-1,yh+ysize-1], /DEVICE, COLOR= tickcolr
ENDFOR

;==============================================================================

; grab the z-buffer content and free its memory
bufpr2out = TVRD()
DEVICE, /CLOSE

; define and fill the return structure holding the image buffers and metadata
thestruc = { $
   xs_pr2 : xwinsize, $
   ys_pr2 : ywinsize, $
   redct : rr, $
   grnct : gg, $
   bluct : bb, $
   pr2_xsect : bufpr2out }

GOTO, OKexit

errorExit:
return, -1

OKexit:
return, thestruc
end
