;===============================================================================
;+
; Copyright Â© 2009, United States Government as represented by the
; Administrator for The National Aeronautics and Space Administration.
; All Rights Reserved.
;
; plot_geo_match_xsections.pro    Morris/SAIC/GPM_GV    March 2009
;
; DESCRIPTION
; -----------
; Takes arrays of geometry-matched PR and GR reflectivity volumes, top and
; bottom heights of the volumes, parameters specifying the array indices of the
; scan line and beginning and ending rays in the array data for which a cross
; section of data is to be plotted, the number of GR elevation sweeps in the
; geometry-matched data, bright band mean height, and an optional plot title,
; and generates vertical cross sections of PR and GR reflectivity.
;
; The plots use a 'smooth' IDL color table showing 1 dBZ color separation.
; The plots use a default value of 320 pixels in height for each of the two
; cross section plots, to match the dimensions of the plots of full resolution
; PR data generated by the 'plot_pr_xsection' procedure.  The width of the
; cross-section plots, and of each plotted ray, varies according to the number
; of rays to be plotted.
;
; Also plots a matching cross section of geometry matched PR-GR reflectivity
; difference in a separate window, using a set of discrete colors defined in
; this procedure, and representing 1 dBZ resolution steps.
;
;
; PARAMETERS
; ----------
; gvz       - Array of volume-matched ground radar reflectivity data, over
;             nsweeps elevations.
; zcor      - Array of volume-matched 2A-25 corrected reflectivity data, over
;             nsweeps elevations.
; top       - Top height of the matched volumes in gvz and zcor, in km.  Same
;             dimensions as gvz and zcor.
; botm      - As above, but bottom height of the volumes.
; bbprox    - As above, but bright band category (above, below, within) of the
;             sample volumes gvz and zcor.
; meanbb    - Mean height of the bright band, in km.
; nsweeps   - number of GR elevation sweeps in the geometry-matched data
; idxscan   - Footprint locations of the PR scan whose data are to be
;             plotted as a vertical cross section.  Zero-based array index
;             into one sweep's worth of data extracted from zcor or gvz.
; idxmin    - Position of the starting ray of the scan to plot in the cross
;             section.  Zero-based array index.
; idxmax    - As above, but ending ray to plot in the cross section.
; caseTitle - (Optional) title to be written into the cross section images.
; gvoff     - (Optional) offset in dBZ to apply to displayed gvz reflectivity.
; s2ku      - Optional binary parameter, indicates that the S-to-Ku frequency
;             adjustment is to be applied to the gvz field, if set to ON (=1).
; PRainType - (Optional) array of PR 2A-25 rain type category for the footprint
;             locations, of same dimensions/locations as idxscan.  If provided,
;             a color-coded bar indicating rain type category will be included
;             on the cross section plots.
; GRainType - (Optional) like PRainType, but rain type is derived from ground
;             radar vertical profiles of reflectivity.
; plotBBsep - (Optional) binary parameter, indicates whether to plot a delimiter
;             between within-BB volumes and adjacent above and below-BB volumes.
;
; CONSTRAINTS
; -----------
; This procedure expects that the proper color table has already been set up,
; such that the geo_match cross sections are plotted into image values in the
; range from 128-255.  See plot_pr_xsection.pro for the color table set-up.
;
; HISTORY
; -------
; 07/09/09 Morris, GPM GV, SAIC
; - Added annotations to cross sections to indicate PctAbvThresh value and
;   GR calibration offset.  Added GVOFF keyword parameter for the latter.
; 07/24/09 Morris, GPM GV, SAIC
; - Added s2ku parameter to plot status of S-to-Ku frequency adjustment to GR
;   reflectivity.
; 08/04/09  Morris/GPM GV/SAIC
; - Changed the color assignments and color bar to match the lower panel of
;   plot_pr_xsection.pro.
; 08/06/09  Morris/GPM GV/SAIC
; - Changed color bar logic to eliminate confusion.
; 05/11/10  Morris/GPM GV/SAIC
; - Changed plotting of bright band upper bound to 0.75 km (750 m) above meanbb.
; - Labeled windows with titles, changed GV acronym to GR.
; - Added mean difference computation/display capability.  Added 'bbprox' as a
;   parameter to support computation of differences above, below, and within BB.
; 06/17/11 Morris, GPM GV, SAIC
; - Added capability to plot a rain type indicator bar at top of PR and GR
;   geo-match data x-sections, using passed PR-derived and/or GR-derived rain
;   type arrays.
; - Filled in descriptions of input parameters missing from prologue.
; 02/07/12  Morris/GPM GV/SAIC
; - Moved the 'A' and 'B' labels to bottoms of plots, and made them thicker
;   and in shadow text.
; - Added labeling of major height ticks on left of plot, and contrasting
;   color/pattern in ticks.
; - Changed the color assignments for rain type "No Data" and "Other" in the
;   PR- and GR-based rain type indicator bands at the tops of the plots.
; 07/26/12  Morris/GPM GV/SAIC
; - Added an option to plot separators delimiting sample volume(s) at the top
;   and bottom of the "within BB" layer.
; 08/01/12  Morris/GPM GV/SAIC
; - Added BBWIDTH option to control plot of dotted lines indicating the
;   BB-affected region, rather than hard-coding of +/-750 m.
; 08/01/12  Morris/GPM GV/SAIC
; - Added HIDE_RNTYPE parameter to inhibit rain type color bars in x-sections.
;
; EMAIL QUESTIONS OR COMMENTS TO:
;       <Bob Morris> kenneth.r.morris@nasa.gov
;       <Matt Schwaller> mathew.r.schwaller@nasa.gov
;-
;===============================================================================

pro plot_geo_match_xsections, gvz, zcor, top, botm, bbprox, meanbb, nsweeps, $
                              idxscan, idxmin, idxmax, TITLE=caseTitle, $
                              GVOFF=gvoff, S2KU=s2ku, PRAINTYPE=PRainType, $
                              GRAINTYPE=GRainType, PLOTBBSEP=plotBBsep, $
                              BBWIDTH=bbwidth, HIDE_RNTYPE=hide_rntype

IF ( N_ELEMENTS(bbwidth) NE 1 ) THEN bbwidth=0.750
IF bbwidth GT 2.0 OR bbwidth LT 0.2 THEN BEGIN
   print, "In plot_geo_match_xsections, overriding outlier bbwidth value:", $
           bbwidth, " km to 0.750 km"
   bbwidth=0.750
ENDIF

hide_rntype = KEYWORD_SET( hide_rntype )

; set up the image size and the width of each ray in pixels
nrays = ABS(idxmax-idxmin)+1
ysize = 320   ; for now -- should be input parm.
xraywidth = ysize/nrays
xsize = xraywidth*nrays
;print, 'xsize, ysize: ', xsize, ysize

xwinsize = xsize + 50
ywinsize = ysize*2
image2render = BYTARR(xwinsize,ysize)  ; hold x-sect image plus color bar
diff_field = FLTARR(xsize,ysize)       ; hold PR-GR values for difference image
diff_field[*,*] = 9999.9
diffimg2render = BYTARR(xwinsize,ysize)  ; hold difference image plus color bar

; build a 1-dbz-resolution color bar
labels = ['BT','15','18','21','24','27','30','33','36','39','42','45','48','51','54','57']

; 1. we do plot the first label (BT)
; 2. we label the bottom of each segment, starting with labels[0] at bottom
;    of bar and ending with last label at bottom of last segment
; 3. we will have this many "segments" in color bar:

       nbarsegs = N_ELEMENTS(labels)

; 4. dbz range of colorbar goes beyond value of last label by one label step (3dBZ):

       zperseg = (FIX(labels[nbarsegs-1])-FIX(labels[nbarsegs-2]))
       zmaxonbar = FIX(labels[nbarsegs-1]) + zperseg
       zminonbar = FIX(labels[1])
       zrange = zmaxonbar-zminonbar

;    we extend the dbz range by one segment to account for the 'below threshold'
;    segment and see how many dbz values we need to show in the total bar length
 
       zrangeext = zrange+zperseg

; 5. we fill the lowest segment with fixed color value for BT (below threshold, < 15dBZ)
; 6. the remaining nbarsegs-1 segments have 127 colors available to be assigned
; 7. increment over the 127 color table colors in (near) equal jumps, when color is
;    associated to next whole dBZ, using the full color range from 129-255

       colorStepPerdbz = 127.0/zrange

; 9. assign an equal number of y-pixels to each dbz (color) within the vertical
;    bounds of the window.  Leave some space above/below bar.

       pixPerColor = (ysize-20)/zrangeext  ; (don't use full image extent for bar)

;    preceding 2 variables are rounded ints, for sizing the bar in the window
;    - the following variables are actual sizes/increments

       ybarsize = pixPerColor * zrangeext + 2  ; (add 2 pixels for bar borders)

; 10. label position y-increment, and color bar "breakpoints":
       ystep = pixPerColor * zPerSeg

; 11. hold colors for all whole dbz from zminonbar to zmaxonbar, plus BT color value:

       color4dbz = BYTARR(zrange+1) 
       color4dbz[*] = 128

; 12. assign bar array and fill color bar values
       colorbar = BYTARR(15,ybarsize)
       colorbar_y = (ysize-ybarsize)/2  ; y position of bottom of colorbar in image

;     do the BT segment first, assign image count 128 to it. Skip the 0th y-pos.
       colorbar[*,1:ystep] = 128

;     do the color bar colors (also image counts) by 1 dBZ steps
       dbzlast = 0
       colorlast = 129
       color4dbz[dbzlast+1] = colorlast
       for i = ystep+1, ybarsize-2 do begin
          if ( (i-1) MOD ystep EQ 0 ) THEN BEGIN
             colorbar[*,i] = 128  ; mark every segment boundary (labeled dBZ location)
          endif else begin
            ; assign a new color if next whole dbz
             thisdbz = FIX( (i-1-ystep)/pixpercolor )
             IF ( thisdbz GT dbzlast ) THEN BEGIN
                dbzlast = thisdbz
                colorlast = FIX( 129 + thisdbz*colorStepPerdbz )
                color4dbz[dbzlast+1] = colorlast
             ENDIF
             colorbar[*,i] = colorlast
;print, 'i: ',i,', dbzlast: ',dbzlast,', colorlast: ',colorlast
         endelse
       endfor
;print, 'max i: ', i-1, ', assigned color: ', colorbar[0,i-1],', colorStepPerdBZ: ', colorStepPerdbz
;print, 'color4dbz: ', color4dbz

; put a white boundary around color bar
colorbar[*,0]=122 & colorbar[*,ybarsize-1]=122
colorbar[0,*]=122 & colorbar[14,*]=122

; burn color bar into image
image2render[xsize+10:xsize+10+15-1,colorbar_y:colorbar_y+ybarsize-1] = colorbar

; build a colorbar for the difference image
ybarsizedif=254
colorbardif = BYTARR(15,ybarsizedif)
colorbar_ydif = (ysize-ybarsizedif)/2  ; y position of bottom of colorbar in image
nlabelsdif = 0
tvlct, rr,gg,bb,/get  ; colors' arrays

red = 0 & blue = 1
for i = 1, ybarsizedif-1 do begin
   colorbardif[*,i] = byte(i/12)+4
   if ( i MOD 12 EQ 0 ) THEN BEGIN
      nlabelsdif = nlabelsdif+1
      colorbardif[*,i] = 0b  ; mark every 1 dBZ (12 rows)
   endif
endfor

; put a white boundary around color bar
colorbardif[*,0]=255 & colorbardif[*,ybarsizedif-1]=255
colorbardif[0,*]=255 & colorbardif[14,*]=255
; burn color bar into image
diffimg2render[xsize+5:xsize+5+15-1,colorbar_ydif:colorbar_ydif+ybarsizedif-1] = colorbardif

imagepr = BYTARR(xsize,ysize)
imagepr[*,*] = 1b ;128B
imagegv = imagepr
img_sweep_sep = imagepr  ; will use this to demarcate the between-sweep bounds
                         ; and the BB layer bounds
imagediff = BYTARR(xsize,ysize)  ; zeroed-out array for difference image, if any
ascend = 1  ; indicates scan direction along +x x-section axis
if (idxmax LT idxmin) THEN ascend = 0

title = "PR and GR Volume Match X-Sections"
WINDOW, 5, xsize=xwinsize, ysize=ywinsize, ypos=50, TITLE = title

gvmax = 0.0 & prmax = 0.0

;-------------------------

plotBBsep = KEYWORD_SET(plotBBsep)
IF plotBBsep THEN BEGIN

  ; identify the highest and lowest samples within the BB-affected layer, by PR ray

  ; make a copy of bbprox and reset the codes for the above-bb points to 6 in the
  ; copy, so that when we subtract we get values outside the normal range
   bbproxmod = bbprox
   idx2change = WHERE( bbproxmod EQ 3, count2chg)
   IF count2chg GT 0 THEN bbproxmod[idx2change] = 6
  ; shift the original bbprox values upwards by 1 sweep, and leave 1st sweep
  ; values as-is
   bbproxunder = bbprox
   bbproxunder[*,1:nsweeps-1] = bbprox[*,0:nsweeps-2]
  ; subtract the bbprox for the overlying layer from the one below. If the result
  ; is 1, then we're at the bottom of the BB layer.  Ignores case where the 1st
  ; sweep is within the bright band.
   bbbounds = bbproxmod-bbproxunder
  ; tally the locations of the BB lower bounds
   idxbbbotms = WHERE(bbbounds EQ 1, countbotms)

  ; find where in-BB samples are at 1st sweep level
   idxbbbotmsabs = WHERE(bbprox[*,0] EQ 2, countbotmsabs)

  ; shift the modified bbprox values downwards by 1 sweep, and leave last sweep
  ; values as-is
   bbproxover = bbproxmod
   bbproxover[*,0:nsweeps-2] = bbproxmod[*,1:nsweeps-1]
  ; subtract the bbprox for the overlying layer from the one below. If the result
  ; is 4, then we're at the top of the BB layer.  Ignores case where the last
  ; sweep is within the bright band.
   bbbounds = bbproxover-bbprox
  ; tally the locations of the BB upper bounds
   idxbbtops = WHERE(bbbounds EQ 4, counttops)

  ; combine the BB top and bottom indicators into one array, encoded as:
  ; 1=bottom, 4=top, 5=sample is both top and bottom in-bb volume
   bbbounds[*,*] = 0
   IF countbotms GT 0 THEN bbbounds[idxbbbotms] = 1
   IF countbotmsabs GT 0 THEN bbbounds[idxbbbotmsabs] = 1
   IF counttops GT 0 THEN bbbounds[idxbbtops] += 4  ; sometimes top=bottom

   bbboundscan = intarr(nrays,2)  ;diagnostic only, tally ray-by-ray for plotted rays

ENDIF

;-------------------------

; fill in the volume-match x-section image with color values mapped by dBZ

for iframe = 0, nsweeps-1  do begin
  ; get this sweep's subarrays
   gvsweep = gvz[*,iframe]
   prsweep = zcor[*,iframe]
   topsweep = top[*,iframe]
   botmsweep = botm[*,iframe]
   IF ( iframe GT 0 ) THEN oversweep = top[*,iframe-1]
   IF plotBBsep THEN BEGIN
      bbproxsweep = bbbounds[*,iframe]
      bbprox4bounds = REFORM(bbproxsweep[idxscan,0])
   ENDIF

  ; find the max values for points along the scan, prior to clipping dBZs
   gvmax = MAX(gvsweep[idxscan])>gvmax
   prmax = MAX(prsweep[idxscan])>prmax

  ; Compute a difference field for the sweep, for points with valid dBZs
   havediff = 0
   sweepdiff = gvsweep
   sweepdiff[*] = 9999.9
  ; do only points with matched valid PR and GR Z values
   idx2diff = WHERE( gvsweep GT 0.0 AND prsweep GT 0.0, count2diff )
   IF count2diff GT 0 THEN BEGIN
      sweepdiff[idx2diff] = prsweep[idx2diff] - gvsweep[idx2diff]
     ; grab the points for our scan points-of-interest
      sweepdiffscan = sweepdiff[idxscan]
      havediff = 1
   ENDIF

  ; get our PR scan's points from the sweep, and scale to image counts
  ; round off the dbz value and look up the assigned image color for the dbz
   coloridx4gate = ( FIX(gvsweep[idxscan]-(zminonbar-1)) > 0 ) < zrange
   gvscan = color4dbz[coloridx4gate]
;if iframe EQ 0 then print, 'gvscan: ', gvscan
   coloridx4gate = ( FIX(prsweep[idxscan]-(zminonbar-1)) > 0 ) < zrange
   prscan = color4dbz[coloridx4gate]

  ; if the current scan overlaps prior scan, adjust plotted bottom to the
  ; midpoint between the two scans
   topscan = topsweep[idxscan]
   botmscan = botmsweep[idxscan]
   IF ( iframe GT 0 ) THEN BEGIN
      overscan = oversweep[idxscan]
      idxoverlap = WHERE( botmscan LT overscan, numovrlap )
      IF ( numovrlap GT 0 ) THEN $
          botmscan[idxoverlap] = (botmscan[idxoverlap]+overscan[idxoverlap])/2.0
   ENDIF

  ; compute image y-locations of sample volume's top and bottom,
  ;   based on 4 pixels per .25 km (80 rays in 320 image pixels)
   kmperpix = 0.25/4.0
   topscan = FIX(topscan/kmperpix)
   botmscan = FIX(botmscan/kmperpix)

  ; do a consistency check between our scan subset and nrays from passed parms.
   nraysgeo = N_ELEMENTS(gvscan)
   IF ( nrays NE nraysgeo ) THEN BEGIN
      print, 'Oh, *%&^$!, do not have matching number of rays in geo_match!'
      goto, errorExit
   ENDIF

  ; plot left-to-right in ascending ray number order; used idxmin and idxmax to
  ; determine whether points are in ascending or descending ray order.  For now
  ; we'll assume that the data we extract for the scan are in sequential ray
  ; order, either ascending or descending, and don't need sorting.

   IF ( ascend EQ 1 ) THEN BEGIN
      istart=0  &  iend=nraysgeo-1  &  istep=1
   ENDIF ELSE BEGIN
      istart=nraysgeo-1  &  iend=0  &  istep=-1
   ENDELSE

  ; fill the image array with dbz values based on pixel bounds of each volume
   xleft = 0
   for iray = istart, iend, istep  do begin
      xright = xleft+xraywidth-1
     ; set flags for marking BB bounds, if activated
      show_bb_botm = 0
      show_bb_top = 0
      IF plotBBsep THEN BEGIN
         IF (bbprox4bounds[iray] MOD 4) EQ 1  THEN BEGIN
            show_bb_botm = 1
;            bbboundscan[iray,0] = iframe+1  ;diagnostic only
         ENDIF
         IF bbprox4bounds[iray] GE 4  THEN BEGIN
            show_bb_top = 1
;            bbboundscan[iray,1] = iframe+1  ;diagnostic only
         ENDIF
      ENDIF
      IF ( botmscan[iray] GE 0 AND topscan[iray] GT 0 ) THEN BEGIN

        ; first deal with image upper bound
         IF topscan[iray] GE ysize THEN BEGIN
            topscan[iray] = ysize-1  ; TALL echoes happen!
            PRINT, 'Adjusted echo top height of: ', topsweep[idxscan[iray]]
            PRINT, 'PR, GR dBZs:', prsweep[idxscan[iray]], gvsweep[idxscan[iray]]
         ENDIF
         IF botmscan[iray] GE ysize THEN BEGIN  ; not THIS tall, I hope!
            PRINT, 'Bottom of echo volume at excessive height: ', $
                   topsweep[idxscan[iray]]
            PRINT, 'Skipping volume.'
            CONTINUE
         ENDIF

        ; paint the sample volumes with predetermined colors
         imagepr[xleft:xright,botmscan[iray]:topscan[iray]] = prscan[iray]
         imagegv[xleft:xright,botmscan[iray]:topscan[iray]] = gvscan[iray]

        ; set up a delimiter for embedding, if volume is deep enough
         IF ( topscan[iray]-botmscan[iray] GT 2 ) THEN BEGIN
           IF show_bb_botm THEN BEGIN
               wider = botmscan[iray]-1 > 0
               wider2 = botmscan[iray]+1 < (ysize-1)
               img_sweep_sep[xleft:xright,wider:wider2] = 200B
            ENDIF
            IF show_bb_top THEN BEGIN
               wider = topscan[iray]-1 > 0
               wider2 = topscan[iray]+1 < (ysize-1)
               img_sweep_sep[xleft:xright,wider:wider2] = 200B
            ENDIF
            img_sweep_sep[xleft:xright,botmscan[iray]:botmscan[iray]] = 100B
          ENDIF
        ; do the difference field if indicated
         IF ( havediff EQ 1 ) THEN $
            diff_field[xleft:xright,botmscan[iray]:topscan[iray]] $
            = sweepdiffscan[iray]
      ENDIF
      xleft = xright+1
   endfor

endfor  ; iframe loop

IF hide_rntype THEN GOTO, skipRnType  ;jump past following block if hiding ON

; burn the rain type indicator into the top of the image, if rain type array is
; provided
IF N_ELEMENTS(PRainType) GT 0 OR N_ELEMENTS(GRainType) GT 0 THEN BEGIN
  ; extract PR rain type along the scan line, for rays to be plotted
   IF N_ELEMENTS(PRainType) GT 0 THEN BEGIN
      rtype2plot = PRainType[idxscan]
      IF N_ELEMENTS(GRainType) EQ 0 THEN gvrtype2plot = PRainType[idxscan] $
      ELSE gvrtype2plot = GRainType[idxscan]
   ENDIF ELSE BEGIN
      rtype2plot = GRainType[idxscan]
      gvrtype2plot = GRainType[idxscan]
   ENDELSE

  ; map the desired color values to the rain types (values = 1, 2, or 3)
   ;img4rtype = [128b, 160b, 230b, 200b]
   img4rtype = [0b, 160b, 230b, 128b]  ; no data, stratiform, convective, other
  ; fill the image array with color values based on x-pixel bounds of each volume
   xleft = 0
   topsweep = top[idxscan,*]              ; height profiles for our rays
   topscan = MAX(topsweep, DIMENSION=2)   ; max defined height for each ray (highest sample w/data)
   kmperpix = 0.25/4.0
   topscan = FIX(topscan/kmperpix)        ; alt. y-value at which to plot GR type 'bars'
   for iray = istart, iend, istep  do begin
      xright = xleft+xraywidth-1
      IF rtype2plot[iray] GT 0 THEN BEGIN
         imagepr[xleft:xright-1,ysize-6:ysize-2] = img4rtype[rtype2plot[iray]]
      ENDIF ELSE imagepr[xleft:xright-1,ysize-6:ysize-2] = img4rtype[0]
      IF gvrtype2plot[iray] GT 0 THEN BEGIN
         imagegv[xleft:xright-1,ysize-7:ysize-3] = img4rtype[gvrtype2plot[iray]]
      ENDIF ELSE imagegv[xleft:xright-1,ysize-7:ysize-3] = img4rtype[0]
      xleft = xright+1
   endfor
ENDIF

skipRnType:

;PRINT, RR[128:255]

; Prepare the difference image from the difference field
; - first, scale the difference to tenths of a dBZ
;diff_field = diff_field * 10.0
; - set up to clip the differences at +/- 10.0 dBZ
idxempty = WHERE( diff_field GT 9999., countmt )
idxgt10 = WHERE( diff_field GE 10.0, countgt10)
idxlt10m = WHERE( diff_field LE -10.0, countlt10m)
; center the zero-difference point at 128 (14)
diff_field = diff_field + 14.0 ;128.0
; set special values for 'big' differences
IF ( countgt10 GT 0 ) THEN diff_field[idxgt10] = 24.001
IF ( countlt10m GT 0 ) THEN diff_field[idxlt10m] = 4.001
IF ( countmt GT 0 ) THEN diff_field[idxempty] = 250.01
imagediff = BYTE( diff_field )

gvmaxstr = STRING(gvmax, FORMAT='(f0.1)')  ; for annotations: GR max dBZ
prmaxstr = STRING(prmax, FORMAT='(f0.1)')  ; ditto, PR

; prep for bright band plotting, labeling
bb_y = FIX(meanbb / kmperpix)
; assume BB is from +bbwidth to -bbwidth km of meanbb, and compute upper/lower y-bounds
bb_y_upr = FIX( (meanbb+bbwidth) / kmperpix )
bb_y_lwr = FIX( (meanbb-bbwidth) / kmperpix )
bbstr = STRING(meanbb, FORMAT='(f0.1)')

; blank out a line of image pixels at the between-sweep volume sample bounds
ixdswpsep = WHERE( img_sweep_sep EQ 100B, countsep )
IF ( countsep GT 0 ) THEN BEGIN
   imagepr[ixdswpsep] = 0B
   imagegv[ixdswpsep] = 0B
ENDIF
; add the contrasting wide line of pixels if this is also the BB boundary
ixdswpsep = WHERE( img_sweep_sep EQ 200B, countsep )
IF ( countsep GT 0 ) THEN BEGIN
   imagepr[ixdswpsep] = 0B
   imagegv[ixdswpsep] = 0B
ENDIF

; PLOT THE IMAGES
;tvlct, rr,gg,bb
image2render[0,0] = imagepr
TV, image2render, 0
image2render[0,0] = imagegv
; insert a separator at the top of the lower image
image2render[*,ysize-2:ysize-1] = 122B
TV, image2render, 1
; assign now, plot later w. different color scheme
diffimg2render[0,0] = imagediff

; ADD THE ANNOTATIONS, SCALES, ETC.
yoff = 0
IF N_ELEMENTS( caseTitle ) EQ 1 THEN BEGIN
   XYOUTS, 15, ysize-20, COLOR=122, caseTitle, /DEVICE
   yoff = 15
ENDIF

; plot this text as shadowed for readability, light over dark
XYOUTS, 9, 10, COLOR=0, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-18, 10, COLOR=0, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 8, 11, COLOR=122, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-17, 11, COLOR=122, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2

XYOUTS, 15, (ysize-20)-yoff, COLOR=122, $
    'GR volume-match samples, 1 dBZ resolution', $
    /DEVICE ;, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 15, (ysize-35)-yoff, COLOR=122, $
   'Max = '+gvmaxstr+' dBZ,  Mean Bright Band = '+bbstr+' km', /DEVICE
s2ku_txt = ''
IF N_ELEMENTS( s2ku ) EQ 1 THEN BEGIN
   if s2ku EQ 1 then s2ku_txt = ', Ku-adjusted'
   if s2ku EQ 0 then s2ku_txt = ', original S-band'
ENDIF
IF N_ELEMENTS( gvoff ) EQ 1 THEN BEGIN
   XYOUTS, 15, (ysize-50)-yoff, COLOR=122, "GR calibration offset = " + $
           STRING(gvoff, FORMAT='(i0)') + " dBZ" + s2ku_txt, /DEVICE
ENDIF
; plot bright band lines: middle, upper bound, lower bound
PLOTS, [0,xsize-1], [bb_y,bb_y], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr,bb_y_upr], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr,bb_y_lwr], /DEVICE, COLOR=0, LINESTYLE=1

IF N_ELEMENTS( caseTitle ) EQ 1 THEN $
   XYOUTS, 15, ysize*2-20, COLOR=122, caseTitle, /DEVICE

; plot this text as shadowed for readability, light over dark
XYOUTS, 9, ysize+10, COLOR=0, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-18, ysize+10, COLOR=0, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 8, ysize+11, COLOR=122, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-17, ysize+11, COLOR=122, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2

XYOUTS, 15, (ysize*2-20)-yoff, COLOR=122, $
    'PR 2A-25 volume-match samples, 1 dBZ resolution', $
    /DEVICE ;, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 15, (ysize*2-35)-yoff, COLOR=122, $
   'Max = '+prmaxstr+' dBZ,  Mean Bright Band = '+bbstr+' km', /DEVICE
; plot bright band lines: middle, upper bound, lower bound
PLOTS, [0,xsize-1], [bb_y+ysize,bb_y+ysize], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr+ysize,bb_y_upr+ysize], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr+ysize,bb_y_lwr+ysize], /DEVICE, COLOR=0, LINESTYLE=1

; label the color bar
FOR i = 0, nbarsegs-1 DO BEGIN
   XYOUTS, xsize+30, colorbar_y + ystep*i - 4, labels[i], COLOR=122, /DEVICE
   XYOUTS, xsize+30, colorbar_y + ystep*i - 4 + ysize, labels[i], COLOR=122, /DEVICE
ENDFOR

; burn in a vertical scale on either side of the two x-sections
tickcolr = 0
FOR h = 1, 19 DO BEGIN
   xlen = 4
   yh = h*16-1
   IF h mod 5 EQ 0 THEN BEGIN
     ; plot major tick and label it with the height in km
      xlen = 7
      XYOUTS, xlen+6, yh-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+6, yh+ysize-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh+ysize-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
   ENDIF
   PLOTS, [xsize-xlen-1,xsize-1], [yh,yh], /DEVICE, COLOR=tickcolr
   PLOTS, [xsize-xlen-1,xsize-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=122, LINESTYLE=1  ; overplot white/dotted
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=122, LINESTYLE=1  ; overplot white/dotted
ENDFOR

; plot the difference image

title = "PR-GR Volume Match Differences"
WINDOW, 6, xsize=xwinsize, ysize=ysize, TITLE = title ;, ypos=50

; set up discrete colors
rgb24=[ $
[90,90,90],$      ;black
[255,255,255],$   ;white
[105,105,105],$   ;dim gray
[211,211,211],$   ;light gray
[255,20,147],$    ;deep pink
[255,105,180],$   ;hot pink
[255,192,203],$   ;pink
[255,0,0],$       ;red
[255,160,122],$   ;light salmon
[205,92,92],$     ;indian red
[139,0,0],$       ;dark red
[255,140,0],$     ;dark orange
[255,205,0],$     ;gold
[255,255,0],$     ;yellow
[255,255,255],$   ;white
[173,255,47],$    ;SpringGreen
[128,128,0],$     ;olive
[0,80,0],$        ;green
[0,139,139],$     ;dark cyan
[0,255,255],$     ;cyan
[65,105,225],$    ;royal blue
[0,0,255], $      ;blue
[153,50,204],$    ;dark orchid
[128,0,128],$     ;purple
[255,0,255] $     ;magenta
]

rr[0:24]=rgb24[0,*]
gg[0:24]=rgb24[1,*]
bb[0:24]=rgb24[2,*]

; set up unassigned/missing areas as gray
rr[230:250] = 100b ;128b ; made darker to split gray from olive green
gg[230:250] = 100b ;128b
bb[230:250] = 100b ;128b
; set 255 to white and 0 to black
rr[255] = 255b
gg[255] = 255b
bb[255] = 255b
rr[0] = 0b
gg[0] = 0b
bb[0] = 0b

; load resulting color table and image
tvlct, rr,gg,bb
TV, diffimg2render

; add annotations to difference image

yoff = 0
IF N_ELEMENTS( caseTitle ) EQ 1 THEN BEGIN
   XYOUTS, 15, ysize-20, COLOR=122, caseTitle, /DEVICE
   yoff = 15
ENDIF

; plot this text as shadowed for readability, light over dark
XYOUTS, 9, 10, COLOR=0, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-18, 10, COLOR=0, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 8, 11, COLOR=122, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-17, 11, COLOR=122, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2

XYOUTS, 15, (ysize-20)-yoff, COLOR=122, $
    'Volume match PR-GR differences, 1 dBZ/color res.', $
    /DEVICE ;, CHARSIZE=1.5, CHARTHICK=2
IF N_ELEMENTS( gvoff ) EQ 1 THEN BEGIN
   XYOUTS, 15, (ysize-35)-yoff, COLOR=122, "GR calibration offset = " + $
           STRING(gvoff, FORMAT='(i0)') + " dBZ" + s2ku_txt, /DEVICE
ENDIF

; burn in a vertical scale on either side of the diff x-section
tickcolr = 0
FOR h = 1, 19 DO BEGIN
   xlen = 4
   yh = h*16-1
   IF h mod 5 EQ 0 THEN BEGIN
     ; plot major tick and label it with the height in km
      xlen = 7
      XYOUTS, xlen+6, yh-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+6, yh+ysize-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh+ysize-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
   ENDIF
   PLOTS, [xsize-xlen-1,xsize-1], [yh,yh], /DEVICE, COLOR=tickcolr
   PLOTS, [xsize-xlen-1,xsize-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=122, LINESTYLE=1  ; overplot white/dotted
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=122, LINESTYLE=1  ; overplot white/dotted
ENDFOR

; plot bright band lines: middle, upper bound, lower bound
PLOTS, [0,xsize-1], [bb_y,bb_y], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr,bb_y_upr], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr,bb_y_lwr], /DEVICE, COLOR=0, LINESTYLE=1

; label the color bar
labels = ['-10','-9','-8','-7','-6','-5','-4','-3','-2','-1',' 0', $
          ' 1',' 2',' 3',' 4',' 5', ' 6',' 7',' 8',' 9','10']
FOR i = 0, nlabelsdif-1 DO BEGIN
   XYOUTS, xsize+25, colorbar_ydif + 12*i + 3, labels[i], COLOR=122, /DEVICE
ENDFOR

; compute mean differences for each BB-relative layer of the x-section

gvz4score = gvz[idxscan,*] & zcor4score = zcor[idxscan,*] & bbprox4score = bbprox[idxscan,*]
idxmeandiffabove = WHERE( gvz4score GT 0.0 and zcor4score GT 0.0 and bbprox4score EQ 3, countabv)
IF countabv GT 0 THEN diffabove=MEAN(zcor4score[idxmeandiffabove]-gvz4score[idxmeandiffabove]) $
ELSE diffabove=-99.99
idxmeandiffin = WHERE( gvz4score GT 0.0 and zcor4score GT 0.0 and bbprox4score EQ 2, countin)
IF countin GT 0 THEN diffin=MEAN(zcor4score[idxmeandiffin]-gvz4score[idxmeandiffin]) $
ELSE diffin=-99.99
idxmeandiffbelow = WHERE( gvz4score GT 0.0 and zcor4score GT 0.0 and bbprox4score EQ 1, countbelow)
IF countbelow GT 0 THEN diffbelow=MEAN(zcor4score[idxmeandiffbelow]-gvz4score[idxmeandiffbelow]) $
ELSE diffbelow=-99.99
PRINT, "Cross Section PR-GR Mean Differences Above, Within, Below Bright Band: "
PRINT, diffabove, diffin, diffbelow
PRINT, "Number of Cross Section Samples Above, Within, Below Bright Band: "
PRINT, countabv, countin, countbelow
errorExit:
END
