;===============================================================================
;+
; Copyright Â© 2009, United States Government as represented by the
; Administrator for The National Aeronautics and Space Administration.
; All Rights Reserved.
;
; plot_pr_xsection.pro    Morris/SAIC/GPM_GV    March 2009
;
; DESCRIPTION
; -----------
; Takes a full array of TRMM 2A-25 3-D reflectivity, parameters specifying the
; scan line and beginning and ending rays in the product for which a cross
; section of data is to be plotted, and bright band mean height and an optional
; plot title, and generates a pair of vertical cross sections of full-resolution
; PR reflectivity.  The top plot uses the coarse color table of the PPI plots
; with a 3 dBZ color binning, and the lower plot uses a 'smooth' IDL color table
; showing 1 dBZ color separation.  A parallax correction for the scan angle of
; the PR is applied to the height of each 250-m PR gate.
;
; The plots use a default value of 320 pixels in height for each of the two
; cross section plots, to match the dimensions of the plots of geometry-matched
; PR and GV data generated by the 'plot_geo_match_xsection' procedure.  The
; width of the cross-section plots, and of each plotted ray, varies according
; to the number of rays to be plotted.
;
; PARAMETERS
; ----------
; scanNumpr  - PR-product-relative number of the PR scan whose data are to be
;              plotted as a vertical cross section.  Zero-based array index.
; raystartpr - Starting ray of the scan to plot in the cross section.  Zero-
;              based array index into the full data array.
; rayendpr   - As above, but ending ray to plot in the cross section.
; z_data     - Full array of (assumed) 2A-25 3-D corrected reflectivity data.
; meanbb     - Mean height of the bright band, in km.
; scale      - Scale factor to be applied to convert z_data to dBZ units.
; rangeBinNums - Holds PR-analyzed bright band height, per ray
; caseTitle  - (Optional) title to be written into the cross section images.
;
; HISTORY
; -------
; 07/2009  Morris/GPM GV/SAIC  
; - Changed coarse color steps to 3 dBZ to match the PPI color scale.  Fixed
;   labeling of same.
; 08/04/09  Morris/GPM GV/SAIC
; - Fixed the color assignments and color bar.
; 08/06/09  Morris/GPM GV/SAIC
; - Changed color bar logic to eliminate confusion.
; 04/22/10  Morris/GPM GV/SAIC
; - Added rangeBinNums parameter containing PR-analyzed bright band height, per
;   ray.  Added plotting of ray-specific BB height to the cross sections.
; - Changed plotting of bright band upper bound to 0.75 km (750 m) above meanbb.
; 05/11/10  Morris/GPM GV/SAIC
; - Disable plotting of ray-specific BB height (comment out).
; - Labeled windows with titles.
; 05/11/10  Morris/GPM GV/SAIC
; - Commented out diagnostic print statements for arzise and x and y sizes.
; 01/21/11  Morris/GPM GV/SAIC
; - Add BBBYRAY keyword option to enable/disable plot of ray-specific BB height
; 07/11/11  Morris/GPM GV/SAIC
; - Add MSL indication to mean BB height label.
; 02/06/12  Morris/GPM GV/SAIC
; - Commented out diagnostic print statement for BB_hgt.
; - Moved the 'A' and 'B' labels to bottoms of plots, and made them thicker
;   and in shadow text.
; - Added labeling of major height ticks on left of plot, and contrasting
;   color/pattern in ticks.
; 08/01/12  Morris/GPM GV/SAIC
; - Added BBWIDTH option to control plot of dotted lines indicating the
;   BB-affected region, rather than hard-coding of +/-750 m.
; 08/10/12  Morris/GPM GV/SAIC
; - Handled case where there is only one ray in the scan to be plotted, i.e.,
;   where raystartpr = rayendpr, which can come up in the new mode of automatic
;   incrementing of the PR scan.
; 08/14/12  Morris/GPM GV/SAIC
; - Changed background gray RGB to [92,92,92] for bottom panel to match the
;   background gray in the PPI colors and PR/GR cross sections.
;
; EMAIL QUESTIONS OR COMMENTS TO:
;       <Bob Morris> kenneth.r.morris@nasa.gov
;       <Matt Schwaller> mathew.r.schwaller@nasa.gov
;-
;===============================================================================

pro plot_pr_xsection, scanNumpr, raystartpr, rayendpr, z_data, meanbb, scale, $
                      rangeBinNums, TITLE=caseTitle, BBBYRAY=BBbyray, $
                      BBWIDTH=bbwidth

; "Include" file for PR-product-specific parameters (i.e., RAYSPERSCAN):
@pr_params.inc

IF ( N_ELEMENTS(bbwidth) NE 1 ) THEN bbwidth=0.750
IF bbwidth GT 2.0 OR bbwidth LT 0.2 THEN BEGIN
   print, "In plot_pr_xsections, overriding outlier bbwidth value:", $
           bbwidth, " km to 0.750 km"
   bbwidth=0.750
ENDIF

; compute the ray angle trig variables for parallax (only cos() used here):
cos_inc_angle = DBLARR(RAYSPERSCAN)
tan_inc_angle = DBLARR(RAYSPERSCAN)
cos_and_tan_of_pr_angle, cos_inc_angle, tan_inc_angle

xsect2d = z_data[scanNumpr, raystartpr:rayendpr, *]
idxclutter = WHERE( xsect2d LT 0.0, nclutr )
IF ( nclutr GT 0 ) THEN xsect2d[idxclutter] = 0.0
xsect2d = xsect2d/scale  ; unscale PR dbz
; get rid of 1st (or 1st and 2nd) dimension(s) of size 1, and flip vertically
; to account for bin order (surface bin = 80)
trimmed = REFORM( xsect2d )
ts = SIZE(trimmed)
IF ts[0] EQ 2 THEN xsect2d = REVERSE( trimmed, 2 ) $  ; 2 or more rays to plot
ELSE xsect2d = REVERSE( trimmed, 1 )                  ; 1 ray to plot

IF (N_ELEMENTS(rangeBinNums) NE 0) THEN BEGIN
; Extract the 2-D range bin number of the bright band level from the 3-D array
;   and initialize a matching bright band height array FOR THIS SCAN/RAY SET
   BB_Bins = REFORM( rangeBinNums[scanNumpr, raystartpr:rayendpr,3] )
   BB_hgt = FLOAT(BB_Bins)
   BB_hgt[*] = BBHGT_UNDEFINED
  ; compute bright band height
   idxhavebb = WHERE ( BB_Bins LE 79, counthavebb )
   IF (counthavebb GT 0) THEN BEGIN
      BB_hgt[idxhavebb] = $
         (79-BB_Bins[idxhavebb]) * (GATE_SPACE/1000.) * cos_inc_angle[raystartpr:rayendpr]
;      print, 'BB_hgt: ', BB_hgt
      BB_hgt[idxhavebb] = BB_hgt[idxhavebb]*16.  ; scale to image pixel y values
      have_bb=1
   ENDIF ELSE BEGIN
      BB_hgt[*] = BB_MISSING
      have_bb=0
   ENDELSE
ENDIF ELSE have_bb=0

;arsize = SIZE( xsect2d )
;print, 'arsize: ', arsize
;nrays = arsize[1] & nbins = arsize[2]
IF ts[0] EQ 2 THEN BEGIN
  ; 2 or more rays to plot, have 2-D xsect2d array
   nrays = ts[1]
   nbins = ts[2]
ENDIF ELSE BEGIN
  ; only one ray to plot, have 1-D xsect2d array
   nrays = 1
   nbins = ts[1]
ENDELSE
ysize = (320/nbins)*nbins & xsize = (ysize/nrays)*nrays
raywidth = xsize/nrays
xwinsize = xsize + 50
ywinsize = ysize*2
image2render = BYTARR(xwinsize,ysize)  ; hold x-sect image plus color bar
;print, 'xsize, ysize: ', xsize, ysize

; set up the 16-level color table from the PPI as the bottom half of color table
; -- set values 122-127 as white, for labels and such
tvlct, rr,gg,bb,/get
rr[122:127] = 255
gg[122:127] = 255
bb[122:127] = 255
tvlct, rr,gg,bb

nsteps = 17      ; number of colors for our image
ystep = ysize/nsteps
ybarsize = ystep * nsteps
colorbar = BYTARR(15,ybarsize)
colorbar_y = (ysize-ybarsize)/2  ; y position of bottom of colorbar in image
; fill color bar values
FOR i = 0, nsteps-1 DO BEGIN
   colorbar[*,ystep*i:ystep*(i+1)-1] = i
ENDFOR

; put a white boundary around color bar
colorbar[*,0]=122 & colorbar[*,ybarsize-1]=122
colorbar[0,*]=122 & colorbar[14,*]=122

; burn color bar into image
image2render[xsize+10:xsize+10+15-1,colorbar_y:colorbar_y+ybarsize-1] = colorbar

; build the x-section as an image array --
; see geo_match/loadcolortable.pro for the dbz mapping to colors used below
maxprval = MAX(xsect2d)
maxprstr = STRING( maxprval, FORMAT='(f0.1)' )

xsectimg = BYTARR(xsize, ysize)
xsectimg[*,*] = 0b ;2B
for k = 0, nrays-1 DO BEGIN
   for l = 0, nbins - 1 DO BEGIN
     ; correct gate top/bottom height for beam parallax and fill image pixels
      xstart=k*raywidth & xend = xstart + raywidth -1
      ystart = FIX( l*4*cos_inc_angle[raystartpr+k] ) < 319
      yend = FIX( (l+1)*4*cos_inc_angle[raystartpr+k] ) < 319
     ; handle 2-D vs. 1-D data array
      IF ts[0] EQ 2 THEN $
         xsectimg[xstart:xend,ystart:yend] = BYTE( ( (xsect2d[k,l]-12.0 > 0)/3 +1)  < 128. ) $
      ELSE xsectimg[xstart:xend,ystart:yend] = BYTE( ( (xsect2d[l]-12.0 > 0)/3 +1)  < 128. )
   endfor
endfor

title = "PR 2A-25 Reflectivity, 250m gates"
WINDOW, 3, xsize=xwinsize, ysize=ywinsize, ypos=50, TITLE = title
image2render[0,0] = xsectimg
; plot the PPI-colored x section in the top half of the window
TV, image2render, 0

; label the color bar
labels = ['BT','15','18','21','24','27','30','33','36','39','42','45','48','51','54','57']
FOR i = 0, nsteps-1 DO BEGIN
   IF i LT nsteps-1 THEN BEGIN
      XYOUTS, xsize+30, ysize+colorbar_y+ystep*(i+1)-4, labels[i], COLOR=122, /DEVICE
   ENDIF
ENDFOR

; get bright band level
bb_y = FIX(meanbb * 16.0)  ; assumes 4 pixels/gate, gate is 0.25 km deep
; assume BB is from +bbwidth km to -bbwidth km of meanbb, and compute upper/lower y-bounds
bb_y_upr = FIX( (meanbb+bbwidth) *16.0 )
bb_y_lwr = FIX( (meanbb-bbwidth) * 16.0 )
bbstr = STRING(meanbb, FORMAT='(f0.1)')

; plot bright band lines: middle, upper bound, lower bound
IF ( KEYWORD_SET(BBbyray) AND have_bb EQ 1 ) THEN BEGIN     ; plot the ray-specific bright band heights
   for k = 0, nrays-1 DO BEGIN
      xstart=k*raywidth & xend = xstart + raywidth -1
      IF (BB_hgt[k] GT 0) THEN PLOTS, [xstart,xend], [BB_hgt[k]+ysize,BB_hgt[k]+ysize], $
                                     /DEVICE, COLOR=0, THICK=2
   endfor
ENDIF
PLOTS, [0,xsize-1], [bb_y+ysize,bb_y+ysize], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr+ysize,bb_y_upr+ysize], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr+ysize,bb_y_lwr+ysize], /DEVICE, COLOR=0, LINESTYLE=1

yoff = 0
IF N_ELEMENTS( caseTitle ) EQ 1 THEN BEGIN
   XYOUTS, 15, ysize+ysize-20, COLOR=122, caseTitle, /DEVICE
   yoff = 15
ENDIF

; plot this text as shadowed for readability, light over dark
XYOUTS, 9, ysize+10, COLOR=0, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-18, ysize+10, COLOR=0, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 8, ysize+11, COLOR=122, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-17, ysize+11, COLOR=122, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2

XYOUTS, 15, ysize+(ysize-20)-yoff, COLOR=122, $
        'Original PR gates, using PPI color scale', /DEVICE
XYOUTS, 15, ysize+(ysize-35)-yoff, COLOR=122, '(3 dBZ steps)', /DEVICE
XYOUTS, 15, ysize+(ysize-50)-yoff, COLOR=122, $
   'Max = '+maxprstr+' dBZ,  Mean Bright Band = '+bbstr+' km MSL', /DEVICE

; do another x-section, using more colors and more resolution of dBZ values
; -- render in image values 128-255, using another color table
image2render[*,*] = 0B

; build a 1-dbz-resolution color bar
; 1. we do plot the first label (BT)
; 2. we label the bottom of each segment, starting with labels[0] at bottom
;    of bar and ending with last label at bottom of last segment
; 3. we will have this many "segments" in color bar:

       nbarsegs = N_ELEMENTS(labels)

; 4. dbz range of colorbar goes beyond value of last label by one label step (3dBZ):

       zperseg = (FIX(labels[nbarsegs-1])-FIX(labels[nbarsegs-2]))
       zmaxonbar = FIX(labels[nbarsegs-1]) + zperseg
       zminonbar = FIX(labels[1])
       zrange = zmaxonbar-zminonbar

;    we extend the dbz range by one segment to account for the 'below threshold'
;    segment and see how many dbz values we need to show in the total bar length
 
       zrangeext = zrange+zperseg

; 5. we fill the lowest segment with fixed color value for BT (below threshold, < 15dBZ)
; 6. the remaining nbarsegs-1 segments have 127 colors available to be assigned
; 7. increment over the 127 color table colors in (near) equal jumps, when color is
;    associated to next whole dBZ, using the full color range from 129-255

       colorStepPerdbz = 127.0/zrange

; 9. assign an equal number of y-pixels to each dbz (color) within the vertical
;    bounds of the window.  Leave some space above/below bar.

       pixPerColor = (ysize-20)/zrangeext  ; (don't use full image extent for bar)

;    preceding 2 variables are rounded ints, for sizing the bar in the window
;    - the following variables are actual sizes/increments

       ybarsize = pixPerColor * zrangeext + 2  ; (add 2 pixels for bar borders)

; 10. label position y-increment, and color bar "breakpoints":
       ystep = pixPerColor * zPerSeg

; 11. hold colors for all whole dbz from zminonbar to zmaxonbar, plus BT color value:

       color4dbz = BYTARR(zrange+1) 
       color4dbz[*] = 128

; 12. assign bar array and fill color bar values
       colorbar = BYTARR(15,ybarsize)
       colorbar_y = (ysize-ybarsize)/2  ; y position of bottom of colorbar in image

;     do the BT segment first, assign image count 128 to it. Skip the 0th y-pos.
       colorbar[*,1:ystep] = 128

;     do the color bar colors (also image counts) by 1 dBZ steps
       dbzlast = 0
       colorlast = 129
       color4dbz[dbzlast+1] = colorlast
       for i = ystep+1, ybarsize-2 do begin
          if ( (i-1) MOD ystep EQ 0 ) THEN BEGIN
             colorbar[*,i] = 128  ; mark every segment boundary (labeled dBZ location)
          endif else begin
            ; assign a new color if next whole dbz
             thisdbz = FIX( (i-1-ystep)/pixpercolor )
             IF ( thisdbz GT dbzlast ) THEN BEGIN
                dbzlast = thisdbz
                colorlast = FIX( 129 + thisdbz*colorStepPerdbz )
                color4dbz[dbzlast+1] = colorlast
             ENDIF
             colorbar[*,i] = colorlast
;print, 'i: ',i,', dbzlast: ',dbzlast,', colorlast: ',colorlast
         endelse
       endfor

;print, 'max i: ', i-1, ', assigned color: ', colorbar[0,i-1],', colorStepPerdBZ: ', colorStepPerdbz
;print, 'color4dbz: ', color4dbz

; put a white boundary around color bar
colorbar[*,0]=122 & colorbar[*,ybarsize-1]=122
colorbar[0,*]=122 & colorbar[14,*]=122

; burn color bar into image
image2render[xsize+10:xsize+10+15-1,colorbar_y:colorbar_y+ybarsize-1] = colorbar

; load compressed color table 33 into LUT values 129-255
loadct, 33, /SILENT
tvlct, rrhi, gghi, bbhi, /get
FOR j = 1,127 DO BEGIN
   rr[j+128] = rrhi[j*2]
   gg[j+128] = gghi[j*2]
   bb[j+128] = bbhi[j*2]
ENDFOR
; 128 is background color (gray 92) for Below Threshold (see DZ in loadcolortable.pro)
rr[128] = 92 & gg[128] = 92 & bb[128]=92
tvlct, rr,gg,bb

; load the image array with PR gate values

xsectimg[*,*] = 0b         ; re-init image array. now using upper half of byte
for k = 0, nrays-1 DO BEGIN
   for l = 0, nbins - 1 DO BEGIN
     ; correct gate top/bottom height for beam parallax and fill image pixels
     xstart=k*raywidth & xend = xstart + raywidth -1
      ystart = FIX( l*4*cos_inc_angle[raystartpr+k] ) < 319
      yend = FIX( (l+1)*4*cos_inc_angle[raystartpr+k] ) < 319
     ; -- every 1 dBZ in reflectivity increments by colorStepPerdbz image counts,
     ;    starting from a bottom cutoff of 15.0 dBZ at image count of 129
     ; round off the dbz value and look up the assigned image color for the dbz
     ; -- handle 2-D vs. 1-D data array
      IF ts[0] EQ 2 THEN $
         coloridx4gate = (FIX(xsect2d[k,l]-(zminonbar-1)) > 0) < zrange $
      ELSE coloridx4gate = (FIX(xsect2d[l]-(zminonbar-1)) > 0) < zrange
      xsectimg[xstart:xend,ystart:yend] = color4dbz[coloridx4gate]
   endfor
endfor
image2render[0,0] = xsectimg
; insert a separator at the top of the lower image
image2render[*,ysize-2:ysize-1] = 122B
TV, image2render, 1

; plot this text as shadowed for readability, light over dark
XYOUTS, 9, 11, COLOR=0, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-18, 11, COLOR=0, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 8, 10, COLOR=122, 'A', /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xsize-17, 10, COLOR=122, 'B', /DEVICE, CHARSIZE=1.5, CHARTHICK=2

IF N_ELEMENTS( caseTitle ) EQ 1 THEN $
   XYOUTS, 15, ysize-20, COLOR=122, caseTitle, /DEVICE
XYOUTS, 15, (ysize-20)-yoff, COLOR=122, 'Original PR gates, with 1 dBZ resolution', $
        /DEVICE ;, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 15, (ysize-35)-yoff, COLOR=122, $
   'Max = '+maxprstr+' dBZ,  Mean Bright Band = '+bbstr+' km MSL', /DEVICE

; plot bright band lines: middle, upper bound, lower bound
IF ( KEYWORD_SET(BBbyray) AND have_bb EQ 1 ) THEN BEGIN     ; plot the ray-specific bright band heights
   for k = 0, nrays-1 DO BEGIN
      xstart=k*raywidth & xend = xstart + raywidth -1
      IF (BB_hgt[k] GT 0) THEN PLOTS, [xstart,xend], [BB_hgt[k],BB_hgt[k]], $
                                     /DEVICE, COLOR=122, THICK=2
   endfor
ENDIF
PLOTS, [0,xsize-1], [bb_y,bb_y], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr,bb_y_upr], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr,bb_y_lwr], /DEVICE, COLOR=0, LINESTYLE=1

; label lower image's color bar
FOR i = 0, nbarsegs-1 DO BEGIN
   XYOUTS, xsize+30, colorbar_y + ystep*i - 3, labels[i], COLOR=122, /DEVICE
ENDFOR

; burn in a vertical scale on either side of the two x-sections
tickcolr = 0
FOR h = 1, 19 DO BEGIN
   xlen = 4
   yh = h*16-1
   IF h mod 5 EQ 0 THEN BEGIN
     ; plot major tick and label it with the height in km
      xlen = 7
      XYOUTS, xlen+6, yh-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+6, yh+ysize-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh+ysize-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
   ENDIF
   PLOTS, [xsize-xlen-1,xsize-1], [yh,yh], /DEVICE, COLOR=0
   PLOTS, [xsize-xlen-1,xsize-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=0
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=122, LINESTYLE=1  ; overplot white/dotted
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=122, LINESTYLE=1  ; overplot white/dotted
ENDFOR

end
