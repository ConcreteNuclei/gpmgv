;===============================================================================
;+
; Copyright Â© 2012, United States Government as represented by the
; Administrator for The National Aeronautics and Space Administration.
; All Rights Reserved.
;
; plot_geo_match_xsections_zbuf.pro    Morris/SAIC/GPM_GV    August 2012
;
; DESCRIPTION
; -----------
; Takes arrays of geometry-matched PR and GR reflectivity volumes, top and
; bottom heights of the volumes, parameters specifying the array indices of the
; scan line and beginning and ending rays in the array data for which a cross
; section of data is to be plotted, the number of GR elevation sweeps in the
; geometry-matched data, bright band mean height, and an optional plot title,
; and generates vertical cross sections of PR and GR reflectivity in a z-buffer.
;
; The plots apply a 'smooth' IDL color table showing 1 dBZ color separation.
; The plots use a default value of 320 pixels in height for each of the two
; cross section plots, to match the dimensions of the plots of full resolution
; PR data generated by the 'plot_pr_xsection' procedure.  The width of the
; cross-section plots, and of each plotted ray, varies according to the number
; of rays to be plotted.
;
; Also plots a matching cross section of geometry matched PR-GR reflectivity
; difference in a separate z-buffer, using a set of discrete colors defined in
; this procedure, and representing 1 dBZ resolution steps.
;
; PARAMETERS
; ----------
; gvz       - Array of volume-matched ground radar reflectivity data, over
;             nsweeps elevations.
; zcor      - Array of volume-matched 2A-25 corrected reflectivity data, over
;             nsweeps elevations.
; top       - Top height of the matched volumes in gvz and zcor, in km.  Same
;             dimensions as gvz and zcor.
; botm      - As above, but bottom height of the volumes.
; bbprox    - As above, but bright band category (above, below, within) of the
;             sample volumes gvz and zcor.
; meanbb    - Mean height of the bright band, in km.
; nsweeps   - number of GR elevation sweeps in the geometry-matched data
; idxscan   - Footprint locations of the PR scan whose data are to be
;             plotted as a vertical cross section.  Zero-based array index
;             into one sweep's worth of data extracted from zcor or gvz.
; idxmin    - Position of the starting ray of the scan to plot in the cross
;             section.  Zero-based array index.
; idxmax    - As above, but ending ray to plot in the cross section.
; caseTitle - (Optional) title to be written into the cross section images.
; gvoff     - (Optional) offset in dBZ to apply to displayed gvz reflectivity.
; s2ku      - Optional binary parameter, indicates that the S-to-Ku frequency
;             adjustment is to be applied to the gvz field, if set to ON (=1).
; PRainType - (Optional) array of PR 2A-25 rain type category for the footprint
;             locations, of same dimensions/locations as idxscan.  If provided,
;             a color-coded bar indicating rain type category will be included
;             on the cross section plots.
; GRainType - (Optional) like PRainType, but rain type is derived from ground
;             radar vertical profiles of reflectivity.
; plotBBsep - (Optional) binary parameter, indicates whether to plot a delimiter
;             between within-BB volumes and adjacent above and below-BB volumes.
;             bbwidth
; hide_rntype - (Optional) binary parameter, indicates whether to plot colored
;               bars along the top of the PR and GR cross-sections indicating the
;               PR and GR rain types identified for the given ray.
; datastartend - A two-element array listing the starting and ending ray numbers
;               to be plotted in the cross section for the PR scan. Zero-based,
;               ranges from 0 to 48. Optional, except where PLOTBOUNDS
;               values are specified and/or LABEL_BY_RAYNUM is set to ON (=1).
;               These values serve 2 purposes: the first is for labeling the
;               L/R edges of the cross section with the PR ray number at that
;               point when LABEL_BY_RAYNUM is set.  The second is to determine
;               the X-positions where each PR ray's data are plotted in the
;               cross sections when PLOTBOUNDS values are given.
; plotbounds    - Optional parameter, a 2-element array listing the minimum
;                 starting and maximum ending ray numbers to be plotted in the
;                 cross section, over all PR scans in the data set.  Zero-based,
;                 values range from 0 to 48.  If provided, the ray widths and
;                 plotted ray locations in the cross sections are set up according
;                 to the number of rays between plotbounds[0] and plotbounds[1].
;                 In essence, the cross-section domain is set up in a fixed manner
;                 based on the this number of rays, where the plotted locations of
;                 each ray depends on the values of plotbounds and datastartend.
;                 This parameter is ignored unless RAYSTARTEND is also specified,
;                 such that the cross sections take on their legacy appearance.
; label_by_raynum - Optional binary parameter.  If set to OFF, then the edges of
;                   the x-sections are labeled with A and B, to orient the
;                   cross section with regard to the line drawn on the PPIs
;                   showing the location of the PR scan selected for display.
;                   IF set to ON, and if RAYSTARTEND values are specified, then
;                   the values of PR ray number contained in RAYSTARTEND are
;                   used to label the L/R edges of the x-section.
; sourceLabelIn  - Alternative string to identify the source of the PR/DPR data
;                  being plotted, e.g. 'Ku/NS'.  Defaults to 'PR 2A-25' if not
;                  given.
; difftext       - Binary parameter.  If set, then plot difference text that is
;                  sent to the terminal to the geo-match image (animation case).
;
; RETURNS
; -------
; Function returns a structure containing the x- and y-dimensions of the two
; z-buffers (PR over GR, and PR-GR cross sections), the z-buffers themselves,
; and the color table for the PR-GR image.
;
; CONSTRAINTS
; -----------
; This function expects that the proper color table has already been set up,
; such that the geo_match cross sections are plotted into image values in the
; range from 128-255.  See plot_pr_xsection.pro for the color table set-up.
;
; SYNOPSIS/BEHAVIOR
;
; plot_geo_match_xsections_zbuf, gvz, zcor, top, botm, bbprox, meanbb, $
;                           nsweeps, idxscan, idxmin, idxmax, TITLE=caseTitle, $
;                           GVOFF=gvoff, S2KU=s2ku, PRAINTYPE=PRainType, $
;                           GRAINTYPE=GRainType, PLOTBBSEP=plotBBsep, $
;                           BBWIDTH=bbwidth, HIDE_RNTYPE=hide_rntype, $
;                           DATASTARTEND=datastartend, PLOTBOUNDS=plotbounds, $
;                           LABEL_BY_RAYNUM=label_by_raynum, $
;                           SOURCELABEL=sourceLabelIn, DIFFTEXT=difftext
;
; 1) If neither DATASTARTEND nor PLOTBOUNDS are specified, then the legacy plot
; behavior is used, where the rays in the PR-GR overlap for the given PR scan are
; 'zoomed' in the horizontal to fill the full width of the cross-section window,
; and the endpoints are labeled A and B.  For example, if there are only two rays
; in the overlap area on the PPI for the user-selected scan, then each ray will be
; plotted with a 160-pixel width.  Akin to a scan-by-scan "zoom to fit" behavior.
; 2) If only DATASTARTEND but not PLOTBOUNDS is specified, then the plot is
; still configured to the legacy behavior, but if the LABEL_BY_RAYNUM parameter is
; also set, then the values specified in DATASTARTEND are used to label the
; endpoints of the cross section, rather than A and B.
; 3) If only PLOTBOUNDS but not DATASTARTEND is specified, then the plot is
; still configured to the legacy behavior, since without DATASTARTEND it is not
; possible to plot the rays in their correct locations with respect to the domain
; defined by PLOTBOUNDS.  An error is reported and the override to the legacy
; behavior is noted.
; 4) If both DATASTARTEND and PLOTBOUNDS are specified, then the number of rays
; between plotbounds[0] and plotbounds[1] is used to configure the plot such
; that this number of rays fit in an approximately 320-pixel-wide window, with each
; ray plotted with the same width. In practice, there are two options which must be
; implemented by the calling function to get the desired behavior. In the first,
; the scans in the PR-GR overlap area are examined, and the lowest and highest ray
; number in the scan set are determined (i.e., at the widest part of the overlap
; area) and passed to this function as the 2-element array "plotbounds".  This
; number of rays is used to configure the plot with the result that those scans
; at the "fattest' part of the overlap area fill the cross section completely, and
; those scans with fewer rays partially fill the cross section plot.   Akin to an
; "optimal zoom" behavior, where each ray is plotted with fixed width, and at a
; fixed position based on its ray number, but the empty area of the cross section
; is minimized.  In the second option, the plot is configured to display all 49
; rays in a PR scan, again where each ray is plotted with fixed width, and at a
; fixed position based on its ray number. This is akin to a 1:1 zoom behavior.
; In either case, only the rays between datastartend[0] and datastartend[1] (i.e.,
; those rays of actual data inside the PR/GR overlap area) are plotted, leaving
; the rest of the plot empty for those rays outside these ray number bounds.
;
; NOTE that the number of rays between datastartend[0] and datastartend[1] and the
; number of rays between idxmin and idxmax must be the same.
;
; HISTORY
; -------
; 07/09/09 Morris, GPM GV, SAIC
; - Added annotations to cross sections to indicate PctAbvThresh value and
;   GR calibration offset.  Added GVOFF keyword parameter for the latter.
; 07/24/09 Morris, GPM GV, SAIC
; - Added s2ku parameter to plot status of S-to-Ku frequency adjustment to GR
;   reflectivity.
; 08/04/09  Morris/GPM GV/SAIC
; - Changed the color assignments and color bar to match the lower panel of
;   plot_pr_xsection.pro.
; 08/06/09  Morris/GPM GV/SAIC
; - Changed color bar logic to eliminate confusion.
; 05/11/10  Morris/GPM GV/SAIC
; - Changed plotting of bright band upper bound to 0.75 km (750 m) above meanbb.
; - Labeled windows with titles, changed GV acronym to GR.
; - Added mean difference computation/display capability.  Added 'bbprox' as a
;   parameter to support computation of differences above, below, and within BB.
; 06/17/11 Morris, GPM GV, SAIC
; - Added capability to plot a rain type indicator bar at top of PR and GR
;   geo-match data x-sections, using passed PR-derived and/or GR-derived rain
;   type arrays.
; - Filled in descriptions of input parameters missing from prologue.
; 02/07/12  Morris/GPM GV/SAIC
; - Moved the 'A' and 'B' labels to bottoms of plots, and made them thicker
;   and in shadow text.
; - Added labeling of major height ticks on left of plot, and contrasting
;   color/pattern in ticks.
; - Changed the color assignments for rain type "No Data" and "Other" in the
;   PR- and GR-based rain type indicator bands at the tops of the plots.
; 07/26/12  Morris/GPM GV/SAIC
; - Added an option to plot separators delimiting sample volume(s) at the top
;   and bottom of the "within BB" layer.
; 08/01/12  Morris/GPM GV/SAIC
; - Added BBWIDTH option to control plot of dotted lines indicating the
;   BB-affected region, rather than hard-coding of +/-750 m.
; 08/01/12  Morris/GPM GV/SAIC
; - Added HIDE_RNTYPE parameter to inhibit rain type color bars in x-sections.
; 08/09/12  Morris/GPM GV/SAIC
; - Added RAYSTARTEND parameter to position the cross section relative to a
;   full PR scan's worth of rays (49) rather than expanding the rays in the
;   PR/GR overlap to the window width.  That is, all rays have a fixed width
;   and position in the x-section plot, based on their ray number in the scan.
;
; 08/10/12  Morris/GPM GV/SAIC
; - CREATED FROM plot_geo_match_xsections.pro.
; - Changed from a procedure to a function that returns a structure holding
;   the window sizes, the PR/GR x-sections image and the PR-GR differences
;   x-section image, and the differences image color table.  Now plots to the
;   Z-buffer rather than directly to display windows to better support rapid
;   updating of the x-section windows when sweeping across the PR scans in the
;   matchup data set.
; 08/14/12  Morris/GPM GV/SAIC
; - Changed endpoint plotting in full-scan, fixed-width mode to plot starting and
;   ending ray number values at the ray location rather than at the far sides of
;   the plot window.
; - Changed the height ticks at the left side of the plots to white with a black
;   shadow for better visibility regardless of the background color.  Got rid of
;   the dotted line overplots for these same ticks.
; - Added a "NO ECHOES" indication for cross sections where no PR/GR valid
;   matches are present for plotted rays along the scan.
; 08/09/12  Morris/GPM GV/SAIC
; - Added STARTEND2SHOW parameter to define a fixed domain for the cross section
;   relative to a specific beginning and ending ray rather than relative to a
;   full PR scan's worth of rays (49).
; 09/06/12  Morris/GPM GV/SAIC
; - Changed behavior such that RAYSTARTEND parameter no longer forces a plot of
;   49 rays, in favor of letting STARTEND2SHOW control the plot domain, when
;   STARTEND2SHOW is specified.  Must still have valid RAYSTARTEND values when
;   STARTEND2SHOW is specified.  When STARTEND2SHOW is not specified, then
;   RAYSTARTEND is used only to override the default A and B endpoint labels
;   when LABEL_BY_RAYNUM is unset.
; - Added LABEL_BY_RAYNUM parameter to explicitly control the type of label
;   plotted at the endpoints of the cross section.
; - Shifted the plotted position of the right-edge label to the middle of that
;   ray.
; - General clean-up of commented-out old code.
; 07/16/13  Morris/GPM GV/SAIC
; - Added SOURCELABEL parameter to override default 'PR 2A-25' label on PR/DPR
;   panel for GPM data cases.
; 05/30/14  Morris/GPM GV/SAIC
; - Added computation/printing of X-sec mean differences when no BB exists.
; -3/16/15  Morris/GPM GV/SAIC
; - Swapped plotted positions of caseTitle and data source/type annotations.
; -3/30/15  Morris/GPM GV/SAIC
; - Added difftext binary keyword parameter to control plotting of mean diff
;   statistics within the PR/GR graphic.  Modified format of the statistics as
;   output to the terminal.
; - Added no_data status flag to the returned structure.
; 07/23/15  Morris/GPM GV/SAIC
; - Fixed rounding of difference field so that colors represent integer values
;   +/-0.5 of the units rather than the truncated value of the units.
; 04/12/16  Morris/GPM GV/SAIC
; - Disabled checks of plotbounds[1] GT 48 and datastartend[1] GT 48 to
;   support cross sections along a fixed ray number.  At some point we need to
;   pass other parameters for the limit check based on plotting modes.
; - Renamed keyword/variable combinations for RAYSTARTEND and STARTEND2SHOW
;   to DATASTARTEND and PLOTBOUNDS to avoid confusing terminology with cross
;   sections along a fixed ray number.
; 09/02/16  Morris/GPM GV/SAIC
; - Changed color table for differences plot to a semi-continuous color scheme
;   ranging between +/- 7 dBZ instead of +/- 10 dBZ.  Left old code in place
;   but skipping over it.
;
; EMAIL QUESTIONS OR COMMENTS TO:
;       <Bob Morris> kenneth.r.morris@nasa.gov
;       <Matt Schwaller> mathew.r.schwaller@nasa.gov
;-
;===============================================================================

function plot_geo_match_xsections_zbuf, gvz, zcor, top, botm, bbprox, meanbb, $
                           nsweeps, idxscan, idxmin, idxmax, TITLE=caseTitle, $
                           GVOFF=gvoff, S2KU=s2ku, PRAINTYPE=PRainType, $
                           GRAINTYPE=GRainType, PLOTBBSEP=plotBBsep, $
                           BBWIDTH=bbwidth, HIDE_RNTYPE=hide_rntype, $
                           DATASTARTEND=datastartend, $
                           PLOTBOUNDS=plotbounds, $
                           LABEL_BY_RAYNUM=label_by_raynum, $
                           SOURCELABEL=sourceLabelIn, $
                           DIFFTEXT=difftext

IF ( N_ELEMENTS(bbwidth) NE 1 ) THEN bbwidth=0.750
IF bbwidth GT 2.0 OR bbwidth LT 0.2 THEN BEGIN
   print, "In plot_geo_match_xsections, overriding outlier bbwidth value:", $
           bbwidth, " km to 0.750 km"
   bbwidth=0.750
ENDIF

hide_rntype = KEYWORD_SET( hide_rntype )
label_by_raynum = KEYWORD_SET( label_by_raynum )

; figure out whether to configure ray width in x-sections based on the range of rays
; defined in plotbounds, or on the number of PR/GR overlap rays in the current scan
CASE N_ELEMENTS(plotbounds) OF
      0 : BEGIN
           ; just configure to do the number of rays in current scan (legacy plot)
            doFixed = 0
          END
      2 : BEGIN
           ; error check the values in plotbounds
HELP, plotbounds
PRINT, plotbounds
            IF plotbounds[0] GT plotbounds[1] THEN BEGIN
               doFixed = 0
               print, "In plot_geo_match_xsections, illegal value for PLOTBOUNDS ", $
                      "must be INTARR(2), with plotbounds[0] LE plotbounds[1]."
               print, "plotbounds: ", plotbounds
               goto, errorExit
            ENDIF ;ELSE BEGIN
;               IF plotbounds[0] LT 0 OR plotbounds[1] GT 48 THEN BEGIN
;                  doFixed = 0
;                  print, "In plot_geo_match_xsections, illegal value for PLOTBOUNDS ", $
;                         "must have plotbounds[0] GE 0, and plotbounds[1] LE 48."
;                  print, "plotbounds: ", plotbounds
;                  goto, errorExit
;               ENDIF
;            ENDELSE
           ; check that datastartend is specified and its values are between plotbounds's
            CASE N_ELEMENTS(datastartend) OF
                 0 : BEGIN
                       doFixed = 0
                       print, "In plot_geo_match_xsections, plotbounds is specified ", $
                              "while values for datastartend are undefined."
                       print, "Defaulting to legacy cross-section appearance."
                     END
                 2 : BEGIN
                      ; error check the values in datastartend against plotbounds
                       IF (plotbounds[0] LE datastartend[0]) AND $
                          (plotbounds[1] GE datastartend[1]) THEN BEGIN
                          doFixed = 1
                       ENDIF ELSE BEGIN
                          doFixed = 0
                          print, "In plot_geo_match_xsections, values for datastartend ", $
                                 "exceed plot limits defined in plotbounds."
                          print, "plotbounds: ", plotbounds
                          print, "datastartend: ", datastartend
                          goto, errorExit
                       ENDELSE
                     END
              ELSE : BEGIN
                       doFixed = 0
                       print, "In plot_geo_match_xsections, illegal value for DATASTARTEND, ", $
                              "must be INTARR(2)."
                       help, datastartend
                       goto, errorExit
                     END
            ENDCASE
          END
   ELSE : BEGIN
            print, "In plot_geo_match_xsections, illegal value for PLOTBOUNDS, ", $
                   "must be either INTARR(2) or undefined.  Overriding to disabled."
            help, plotbounds
            doFixed = 0
          END
ENDCASE

;PRINT, "" & PRINT, "doFixed: ", doFixed & PRINT, ""

; figure out how to label the ends of the cross section based on DATASTARTEND presence/values
; -- initialize to legacy labels, then check DATASTARTEND status for override
leftlbl = 'A'
rightlbl = 'B'
IF ( label_by_raynum ) THEN BEGIN
  ; override the A and B labels if datastartend values pass muster
   CASE N_ELEMENTS(datastartend) OF
      0 : ; just label with A at left, B at right (legacy plot)
      2 : BEGIN
           ; error check the values in datastartend against idxmin, idxmax and PR range
           ; first, just check order of values
            IF datastartend[0] GT datastartend[1] THEN BEGIN
               print, "In plot_geo_match_xsections, illegal value for DATASTARTEND", $
                      "must be INTARR(2), with datastartend[0] LE datastartend[1]."
               print, "datastartend: ", datastartend
               IF doFixed THEN goto, errorExit
            ENDIF ELSE BEGIN
              ; check against physical range for PR
              ; -- this check already would have passed if PLOTBOUNDS was specified,
              ;    no need to exit if failed here, just default to L and H
               IF datastartend[0] LT 0 OR datastartend[1] GT 48 THEN BEGIN
                  print, ''
;                  print, "In plot_geo_match_xsections, illegal value for DATASTARTEND, ", $
;                         "must have datastartend[0] GE 0, and datastartend[1] LE 48."
                  print, "datastartend: ", datastartend
                  print, "Overriding L/R labels to L(ow) and H(igh)."
                  print, ''
                  leftlbl = 'L'
                  rightlbl = 'H'
                  ; goto, errorExit
               ENDIF ELSE BEGIN
                 ; check against idxmax-idxmin range
                  IF (datastartend[1]-datastartend[0]) NE ABS(idxmax-idxmin) THEN BEGIN
                     print, "In plot_geo_match_xsections, mismatch between DATASTARTEND ", $
                            "range and idxmin and idxmax range."
                     print, "datastartend: ", datastartend
                     print, "idxmin, idxmax: ", idxmin, idxmax
                     goto, errorExit
                  ENDIF ELSE BEGIN
                    ; passed all checks, use datastartend to label ends of x-section
                     leftlbl=STRING(datastartend[0]+1, FORMAT='(I0)')
                     rightlbl=STRING(datastartend[1]+1, FORMAT='(I0)')
                  ENDELSE
               ENDELSE
            ENDELSE
          END
   ELSE : BEGIN
            print, "In plot_geo_match_xsections, illegal value for DATASTARTEND, ", $
                   "must be either INTARR(2) or undefined.  Overriding to A and B."
            help, datastartend
          END
   ENDCASE
ENDIF

IF N_ELEMENTS( sourceLabelIn ) EQ 1 THEN BEGIN
   sourceLabel = sourceLabelIn 
   sourceLabelDiff = sourceLabelIn
ENDIF ELSE BEGIN
   sourceLabel = 'PR 2A-25'
   sourceLabelDiff = 'PR'
ENDELSE

; set up the image size, the width of each ray in pixels, and x-offset of
; first ray to be plotted relative to left edge of window
IF doFixed THEN nrays = plotbounds[1]-plotbounds[0]+1 $
           ELSE nrays = ABS(idxmax-idxmin)+1

ysize = 320   ; for now -- should be input parm.
xraywidth = ysize/nrays
xsize = xraywidth*nrays
;print, 'xsize, ysize: ', xsize, ysize

; xoff: Where is the first ray plotted on the x-section window, x-wise?
IF doFixed THEN xoff = xraywidth*(datastartend[0]-plotbounds[0]) $
           ELSE xoff = 0  ; non-fixed-size window, legacy appearance

xwinsize = xsize + 50
ywinsize = ysize*2
image2render = BYTARR(xwinsize,ysize)  ; hold x-sect image plus color bar
diff_field = FLTARR(xsize,ysize)       ; hold PR-GR values for difference image
diff_field[*,*] = 9999.9
diffimg2render = BYTARR(xwinsize,ysize)  ; hold difference image plus color bar

;-------------------------------------------

; build a 1-dbz-resolution color bar
labels = ['BT','15','18','21','24','27','30','33','36','39','42','45','48','51','54','57']

; 1. we do plot the first label (BT)
; 2. we label the bottom of each segment, starting with labels[0] at bottom
;    of bar and ending with last label at bottom of last segment
; 3. we will have this many "segments" in color bar:

       nbarsegs = N_ELEMENTS(labels)

; 4. dbz range of colorbar goes beyond value of last label by one label step (3dBZ):

       zperseg = (FIX(labels[nbarsegs-1])-FIX(labels[nbarsegs-2]))
       zmaxonbar = FIX(labels[nbarsegs-1]) + zperseg
       zminonbar = FIX(labels[1])
       zrange = zmaxonbar-zminonbar

;    we extend the dbz range by one segment to account for the 'below threshold'
;    segment and see how many dbz values we need to show in the total bar length
 
       zrangeext = zrange+zperseg

; 5. we fill the lowest segment with fixed color value for BT (below threshold, < 15dBZ)
; 6. the remaining nbarsegs-1 segments have 127 colors available to be assigned
; 7. increment over the 127 color table colors in (near) equal jumps, when color is
;    associated to next whole dBZ, using the full color range from 129-255

       colorStepPerdbz = 127.0/zrange

; 9. assign an equal number of y-pixels to each dbz (color) within the vertical
;    bounds of the window.  Leave some space above/below bar.

       pixPerColor = (ysize-20)/zrangeext  ; (don't use full image extent for bar)

;    preceding 2 variables are rounded ints, for sizing the bar in the window
;    - the following variables are actual sizes/increments

       ybarsize = pixPerColor * zrangeext + 2  ; (add 2 pixels for bar borders)

; 10. label position y-increment, and color bar "breakpoints":
       ystep = pixPerColor * zPerSeg

; 11. hold colors for all whole dbz from zminonbar to zmaxonbar, plus BT color value:

       color4dbz = BYTARR(zrange+1) 
       color4dbz[*] = 128

; 12. assign bar array and fill color bar values
       colorbar = BYTARR(15,ybarsize)
       colorbar_y = (ysize-ybarsize)/2  ; y position of bottom of colorbar in image

;     do the BT segment first, assign image count 128 to it. Skip the 0th y-pos.
       colorbar[*,1:ystep] = 128

;     do the color bar colors (also image counts) by 1 dBZ steps
       dbzlast = 0
       colorlast = 129
       color4dbz[dbzlast+1] = colorlast
       for i = ystep+1, ybarsize-2 do begin
          if ( (i-1) MOD ystep EQ 0 ) THEN BEGIN
             colorbar[*,i] = 128  ; mark every segment boundary (labeled dBZ location)
          endif else begin
            ; assign a new color if next whole dbz
             thisdbz = FIX( (i-1-ystep)/pixpercolor )
             IF ( thisdbz GT dbzlast ) THEN BEGIN
                dbzlast = thisdbz
                colorlast = FIX( 129 + thisdbz*colorStepPerdbz )
                color4dbz[dbzlast+1] = colorlast
             ENDIF
             colorbar[*,i] = colorlast
         endelse
       endfor

; put a white boundary around color bar
colorbar[*,0]=122 & colorbar[*,ybarsize-1]=122
colorbar[0,*]=122 & colorbar[14,*]=122

; burn color bar into image
image2render[xsize+10:xsize+10+15-1,colorbar_y:colorbar_y+ybarsize-1] = colorbar

; build a colorbar for the difference image
ybarsizedif=15*12+2 ;254
colorbardif = BYTARR(15,ybarsizedif)
colorbar_ydif = (ysize-ybarsizedif)/2  ; y position of bottom of colorbar in image
nlabelsdif = 0
tvlct, rr,gg,bb,/get  ; colors' arrays

red = 0 & blue = 1
for i = 1, ybarsizedif-1 do begin
   colorbardif[*,i] = byte(i/12)+7  ; start further along than 4, fewer colors being used
   if ( i MOD 12 EQ 0 ) THEN BEGIN
      nlabelsdif = nlabelsdif+1
      colorbardif[*,i] = 0b  ; mark every 1 dBZ (12 rows)
   endif
endfor

; put a white boundary around color bar
colorbardif[*,0]=255 & colorbardif[*,ybarsizedif-1]=255
colorbardif[0,*]=255 & colorbardif[14,*]=255
; burn color bar into image
diffimg2render[xsize+5:xsize+5+15-1,colorbar_ydif:colorbar_ydif+ybarsizedif-1] = colorbardif

;-------------------------------------------

imagepr = BYTARR(xsize,ysize)
imagepr[*,*] = 1b ;128B
imagegv = imagepr
img_sweep_sep = imagepr  ; will use this to demarcate the between-sweep bounds
                         ; and the BB layer bounds
imagediff = BYTARR(xsize,ysize)  ; zeroed-out array for difference image, if any
ascend = 1  ; indicates scan direction along +x x-section axis
if (idxmax LT idxmin) THEN ascend = 0   ; don't think this can ever happen

SET_PLOT,'Z'
; set up the z-buffer device, and set baseline character size to match up
; to how things would look if plotting directly to 'X' device, as 'Z'
; device has different pixels/cm scaling.  Little fuzzy on this, but it works.
DEVICE, SET_RESOLUTION = [xwinsize,ywinsize], SET_CHARACTER_SIZE=[6,10]

gvmax = 0.0 & prmax = 0.0

;-------------------------

plotBBsep = KEYWORD_SET(plotBBsep)
IF plotBBsep THEN BEGIN

  ; identify the highest and lowest samples within the BB-affected layer, by PR ray

  ; make a copy of bbprox and reset the codes for the above-bb points to 6 in the
  ; copy, so that when we subtract we get values outside the normal range
   bbproxmod = bbprox
   idx2change = WHERE( bbproxmod EQ 3, count2chg)
   IF count2chg GT 0 THEN bbproxmod[idx2change] = 6
  ; shift the original bbprox values upwards by 1 sweep, and leave 1st sweep
  ; values as-is
   bbproxunder = bbprox
   bbproxunder[*,1:nsweeps-1] = bbprox[*,0:nsweeps-2]
  ; subtract the bbprox for the overlying layer from the one below. If the result
  ; is 1, then we're at the bottom of the BB layer.  Ignores case where the 1st
  ; sweep is within the bright band.
   bbbounds = bbproxmod-bbproxunder
  ; tally the locations of the BB lower bounds
   idxbbbotms = WHERE(bbbounds EQ 1, countbotms)

  ; find where in-BB samples are at 1st sweep level
   idxbbbotmsabs = WHERE(bbprox[*,0] EQ 2, countbotmsabs)

  ; shift the modified bbprox values downwards by 1 sweep, and leave last sweep
  ; values as-is
   bbproxover = bbproxmod
   bbproxover[*,0:nsweeps-2] = bbproxmod[*,1:nsweeps-1]
  ; subtract the bbprox for the overlying layer from the one below. If the result
  ; is 4, then we're at the top of the BB layer.  Ignores case where the last
  ; sweep is within the bright band.
   bbbounds = bbproxover-bbprox
  ; tally the locations of the BB upper bounds
   idxbbtops = WHERE(bbbounds EQ 4, counttops)

  ; combine the BB top and bottom indicators into one array, encoded as:
  ; 1=bottom, 4=top, 5=sample is both top and bottom in-bb volume
   bbbounds[*,*] = 0
   IF countbotms GT 0 THEN bbbounds[idxbbbotms] = 1
   IF countbotmsabs GT 0 THEN bbbounds[idxbbbotmsabs] = 1
   IF counttops GT 0 THEN bbbounds[idxbbtops] += 4  ; sometimes top=bottom

   bbboundscan = intarr(nrays,2)  ;diagnostic only, tally ray-by-ray for plotted rays

ENDIF

;-------------------------

; fill in the volume-match x-section image with color values mapped by dBZ
no_data = 1   ; assume there are no samples in x-section until proven otherwise
for iframe = 0, nsweeps-1  do begin
  ; get this sweep's subarrays
   gvsweep = gvz[*,iframe]
   prsweep = zcor[*,iframe]
   topsweep = top[*,iframe]
   botmsweep = botm[*,iframe]
   IF ( iframe GT 0 ) THEN oversweep = top[*,iframe-1]
   IF plotBBsep THEN BEGIN
      bbproxsweep = bbbounds[*,iframe]
      bbprox4bounds = REFORM(bbproxsweep[idxscan,0])
   ENDIF

  ; find the max values for points along the scan, prior to clipping dBZs
   gvmax = MAX(gvsweep[idxscan])>gvmax
   prmax = MAX(prsweep[idxscan])>prmax

  ; Compute a difference field for the sweep, for points with valid dBZs
   havediff = 0
   sweepdiff = gvsweep
   sweepdiff[*] = 9999.9
  ; do only points with matched valid PR and GR Z values
   idx2diff = WHERE( gvsweep GT 0.0 AND prsweep GT 0.0, count2diff )
   IF count2diff GT 0 THEN BEGIN
      sweepdiff[idx2diff] = prsweep[idx2diff] - gvsweep[idx2diff]
     ; grab the points for our scan points-of-interest
      sweepdiffscan = sweepdiff[idxscan]
      havediff = 1
   ENDIF

  ; get our PR scan's points from the sweep, and scale to image counts
  ; round off the dbz value and look up the assigned image color for the dbz
   coloridx4gate = ( FIX(gvsweep[idxscan]-(zminonbar-1)) > 0 ) < zrange
   gvscan = color4dbz[coloridx4gate]
   coloridx4gate = ( FIX(prsweep[idxscan]-(zminonbar-1)) > 0 ) < zrange
   prscan = color4dbz[coloridx4gate]

  ; if the current scan vertically overlaps prior scan, adjust plotted bottom
  ; to the midpoint between the two scans
   topscan = topsweep[idxscan]
   botmscan = botmsweep[idxscan]
   IF ( iframe GT 0 ) THEN BEGIN
      overscan = oversweep[idxscan]
      idxoverlap = WHERE( botmscan LT overscan, numovrlap )
      IF ( numovrlap GT 0 ) THEN $
          botmscan[idxoverlap] = (botmscan[idxoverlap]+overscan[idxoverlap])/2.0
   ENDIF

  ; compute image y-locations of sample volume's top and bottom,
  ;   based on 4 pixels per .25 km (80 rays in 320 image pixels)
   kmperpix = 0.25/4.0
   topscan = FIX(topscan/kmperpix)
   botmscan = FIX(botmscan/kmperpix)

  ; do a consistency check between our scan subset and nrays from passed parms.
   nraysgeo = N_ELEMENTS(gvscan)
   IF ( doFixed EQ 0 AND nrays NE nraysgeo ) THEN BEGIN
      print, 'Oh, *%&^$!, do not have matching number of rays in geo_match!'
      goto, errorExit
   ENDIF

  ; plot left-to-right in ascending ray number order; used idxmin and idxmax to
  ; determine whether points are in ascending or descending ray order.  For now
  ; we'll assume that the data we extract for the scan are in sequential ray
  ; order, either ascending or descending, and don't need sorting.

   IF ( ascend EQ 1 ) THEN BEGIN
      istart=0  &  iend=nraysgeo-1  &  istep=1
   ENDIF ELSE BEGIN
      istart=nraysgeo-1  &  iend=0  &  istep=-1
   ENDELSE

  ; fill the image array with dbz values based on pixel bounds of each volume
   xleft = xoff
   for iray = istart, iend, istep  do begin
      xright = xleft+xraywidth-1
     ; set flags for marking BB bounds, if activated
      show_bb_botm = 0
      show_bb_top = 0
      IF plotBBsep THEN BEGIN
         IF (bbprox4bounds[iray] MOD 4) EQ 1  THEN BEGIN
            show_bb_botm = 1
;            bbboundscan[iray,0] = iframe+1  ;diagnostic only
         ENDIF
         IF bbprox4bounds[iray] GE 4  THEN BEGIN
            show_bb_top = 1
;            bbboundscan[iray,1] = iframe+1  ;diagnostic only
         ENDIF
      ENDIF
      IF ( botmscan[iray] GE 0 AND topscan[iray] GT 0 ) THEN BEGIN
         no_data = 0    ; we have points to plot!

        ; first deal with image upper bound
         IF topscan[iray] GE ysize THEN BEGIN
            topscan[iray] = ysize-1  ; TALL echoes happen!
            PRINT, 'Adjusted echo top height of: ', topsweep[idxscan[iray]]
            PRINT, 'PR, GR dBZs:', prsweep[idxscan[iray]], gvsweep[idxscan[iray]]
         ENDIF
         IF botmscan[iray] GE ysize THEN BEGIN  ; not THIS tall, I hope!
            PRINT, 'Bottom of echo volume at excessive height: ', $
                   topsweep[idxscan[iray]]
            PRINT, 'Skipping volume.'
            CONTINUE
         ENDIF

        ; paint the sample volumes with predetermined colors
         imagepr[xleft:xright,botmscan[iray]:topscan[iray]] = prscan[iray]
         imagegv[xleft:xright,botmscan[iray]:topscan[iray]] = gvscan[iray]

        ; set up a delimiter for embedding, if volume is deep enough
        ; -- skip this except for BBsep if there are too many sweeps (RHI mode)
         IF ( topscan[iray]-botmscan[iray] GT 2 ) THEN BEGIN
            IF show_bb_botm THEN BEGIN
               wider = botmscan[iray]-1 > 0
               wider2 = botmscan[iray]+1 < (ysize-1)
               img_sweep_sep[xleft:xright,wider:wider2] = 200B
            ENDIF
            IF show_bb_top THEN BEGIN
               wider = topscan[iray]-1 > 0
               wider2 = topscan[iray]+1 < (ysize-1)
               img_sweep_sep[xleft:xright,wider:wider2] = 200B
            ENDIF
            IF nsweeps LT 20 THEN $
               img_sweep_sep[xleft:xright,botmscan[iray]:botmscan[iray]] = 100B
         ENDIF
        ; do the difference field if indicated
         IF ( havediff EQ 1 ) THEN $
            diff_field[xleft:xright,botmscan[iray]:topscan[iray]] $
            = sweepdiffscan[iray]
      ENDIF
      xleft = xright+1
   endfor

endfor  ; iframe loop

;-------------------------

IF hide_rntype THEN GOTO, skipRnType  ;jump past following block if hiding ON

; burn the rain type indicator into the top of the image, if rain type array is
; provided
IF N_ELEMENTS(PRainType) GT 0 OR N_ELEMENTS(GRainType) GT 0 THEN BEGIN
  ; extract PR rain type along the scan line, for rays to be plotted
   IF N_ELEMENTS(PRainType) GT 0 THEN BEGIN
      rtype2plot = PRainType[idxscan]
      IF N_ELEMENTS(GRainType) EQ 0 THEN gvrtype2plot = PRainType[idxscan] $
      ELSE gvrtype2plot = GRainType[idxscan]
   ENDIF ELSE BEGIN
      rtype2plot = GRainType[idxscan]
      gvrtype2plot = GRainType[idxscan]
   ENDELSE

  ; map the desired color values to the rain types (values = 1, 2, or 3)
   img4rtype = [0b, 160b, 230b, 128b]  ; no data, stratiform, convective, other

  ; fill the image array with raintype color values based on x-pixel bounds of each volume
   xleft = xoff
   topsweep = top[idxscan,*]              ; height profiles for our rays
   topscan = MAX(topsweep, DIMENSION=2)   ; max defined height for each ray (highest sample w/data)
   kmperpix = 0.25/4.0
   topscan = FIX(topscan/kmperpix)        ; alt. y-value at which to plot GR type 'bars'

   for iray = istart, iend, istep  do begin
      xright = xleft+xraywidth-1
      IF rtype2plot[iray] GT 0 THEN $
         imagepr[xleft:xright-1,ysize-6:ysize-2] = img4rtype[rtype2plot[iray]] $
      ELSE imagepr[xleft:xright-1,ysize-6:ysize-2] = img4rtype[0]
      IF gvrtype2plot[iray] GT 0 THEN $
         imagegv[xleft:xright-1,ysize-7:ysize-3] = img4rtype[gvrtype2plot[iray]] $
      ELSE imagegv[xleft:xright-1,ysize-7:ysize-3] = img4rtype[0]
      xleft = xright+1
   endfor

ENDIF

skipRnType:

;-------------------------

; Prepare the difference image from the difference field
GOTO, BILL_OLSONS    ; skip following block, do smaller difference ranges now

; - set up to clip the differences at +/- 10.0 dBZ
idxempty = WHERE( diff_field GT 9999., countmt )
idxgt10 = WHERE( diff_field GE 10.0, countgt10)
idxlt10m = WHERE( diff_field LE -10.0, countlt10m)
; center the zero-difference point at 128 (14), AND ROUND UP (JULY 2015 CHANGE)
diff_field = diff_field + 14.5 ;128.0
; set special values for 'big' differences
IF ( countgt10 GT 0 ) THEN diff_field[idxgt10] = 24.001
IF ( countlt10m GT 0 ) THEN diff_field[idxlt10m] = 4.001
IF ( countmt GT 0 ) THEN diff_field[idxempty] = 250.01
GOTO, ORIGINAL   ; skip over following block if block above was not skipped

BILL_OLSONS:
; - set up to clip the differences at +/- 7.0 dBZ
idxempty = WHERE( diff_field GT 9999., countmt )
idxgt10 = WHERE( diff_field GE 7.0, countgt10)
idxlt10m = WHERE( diff_field LE -7.0, countlt10m)
; center the zero-difference point at color index 14, AND ROUND UP
diff_field = diff_field + 14.5
; set special values for 'big' differences
IF ( countgt10 GT 0 ) THEN diff_field[idxgt10] = 21.001
IF ( countlt10m GT 0 ) THEN diff_field[idxlt10m] = 7.001
IF ( countmt GT 0 ) THEN diff_field[idxempty] = 250.01

ORIGINAL:
imagediff = BYTE( diff_field )

gvmaxstr = STRING(gvmax, FORMAT='(f0.1)')  ; for annotations: GR max dBZ
prmaxstr = STRING(prmax, FORMAT='(f0.1)')  ; ditto, PR

;-------------------------

; prep for bright band plotting, labeling
bb_y = FIX(meanbb / kmperpix)
; assume BB is from +bbwidth to -bbwidth km of meanbb, and compute upper/lower y-bounds
bb_y_upr = FIX( (meanbb+bbwidth) / kmperpix )
bb_y_lwr = FIX( (meanbb-bbwidth) / kmperpix )
bbstr = STRING(meanbb, FORMAT='(f0.1)')

; blank out a line of image pixels at the between-sweep volume sample bounds
ixdswpsep = WHERE( img_sweep_sep EQ 100B, countsep )
IF ( countsep GT 0 ) THEN BEGIN
   imagepr[ixdswpsep] = 0B
   imagegv[ixdswpsep] = 0B
ENDIF
; add the contrasting wide line of pixels if this is also the BB boundary
ixdswpsep = WHERE( img_sweep_sep EQ 200B, countsep )
IF ( countsep GT 0 ) THEN BEGIN
   imagepr[ixdswpsep] = 0B
   imagegv[ixdswpsep] = 0B
ENDIF

;-------------------------

; compute and output mean differences for each BB-relative layer of the x-section

gvz4score = gvz[idxscan,*] & zcor4score = zcor[idxscan,*] & bbprox4score = bbprox[idxscan,*]

idxmeandiffabove = WHERE( gvz4score GT 0.0 and zcor4score GT 0.0 and bbprox4score EQ 3, countabv)
IF countabv GT 0 THEN diffabove=MEAN(zcor4score[idxmeandiffabove]-gvz4score[idxmeandiffabove]) $
ELSE diffabove=-99.99

idxmeandiffin = WHERE( gvz4score GT 0.0 and zcor4score GT 0.0 and bbprox4score EQ 2, countin)
IF countin GT 0 THEN diffin=MEAN(zcor4score[idxmeandiffin]-gvz4score[idxmeandiffin]) $xsize/2-70
ELSE diffin=-99.99

idxmeandiffbelow = WHERE( gvz4score GT 0.0 and zcor4score GT 0.0 and bbprox4score EQ 1, countbelow)
IF countbelow GT 0 THEN diffbelow=MEAN(zcor4score[idxmeandiffbelow]-gvz4score[idxmeandiffbelow]) $
ELSE diffbelow=-99.99

PRINT, ""
IF (countabv+countin+countbelow GT 0) THEN BEGIN
   PRINT, "Cross Section PR-GR Mean Differences Above / Within / Below Bright Band: ", $
          STRING(diffabove, FORMAT='(f0.2)') + ' / ' + STRING(diffin, FORMAT='(f0.2)') $
          +  ' / ' + STRING(diffbelow, FORMAT='(f0.2)') ;diffabove, diffin, diffbelow
   PRINT, "     Number of Cross Section Samples Above / Within / Below Bright Band: ", $
          STRING(countabv, FORMAT='(I0)') + ' / ' + STRING(countin, FORMAT='(I0)') $
          + ' / ' + STRING(countbelow, FORMAT='(I0)')
ENDIF ELSE BEGIN
   idxmeandiffany = WHERE( gvz4score GT 0.0 and zcor4score GT 0.0, countany)
   IF countany GT 0 THEN BEGIN
      diffany=MEAN(zcor4score[idxmeandiffany]-gvz4score[idxmeandiffany])
      PRINT, "Cross Section PR-GR Mean Differences and Number of Samples, indeterminate Bright Band: "
      PRINT, "DPR-GR Mean Diff.: ", diffany, ",  Number of samples: ", countany
   ENDIF ELSE BEGIN
      diffany=-99.99
      PRINT, "DPR-GR Mean Diff. : No qualifying samples"
   ENDELSE
ENDELSE

;-------------------------

; PLOT THE PR AND GR X-SECTION IMAGES
;tvlct, rr,gg,bb
image2render[0,0] = imagepr
TV, image2render, 0
image2render[0,0] = imagegv
; insert a separator at the top of the lower image
image2render[*,ysize-2:ysize-1] = 122B
TV, image2render, 1
; assign now, plot later w. different color scheme
diffimg2render[0,0] = imagediff

; ADD THE ANNOTATIONS, SCALES, ETC.
; -- GR panel first

yoff = 0
IF N_ELEMENTS( caseTitle ) EQ 1 THEN BEGIN
   yoff = 15
   XYOUTS, 15, ysize-20-yoff, COLOR=122, caseTitle, /DEVICE
ENDIF

yoffleft=0 & yoffright=0  ; vertical offsets to be reset when labels overlap
IF doFixed THEN BEGIN
  ; compute position of ray labels, relative to where the rays are plotted, dealing
  ; with window bounds.  Locate relative to ray=plotbounds[0] at leftmost position
   xlblposright = (((datastartend[1]-plotbounds[0])*xraywidth + xraywidth/2) < (xsize-18)) > 6
   xlblposleft = ((datastartend[0]-plotbounds[0])*xraywidth > 6) < (xsize-18)
  ; deal with potential label overlaps
   IF xlblposright LE (xlblposleft+20) THEN BEGIN
      IF datastartend[0] GT 25 THEN BEGIN
         yoffleft = 15
         xlblposleft = xlblposleft < (xlblposright-6)
      ENDIF ELSE BEGIN
         xlblposright = xlblposright > (xlblposleft+6)
         yoffright = 15
      ENDELSE
   ENDIF
ENDIF ELSE BEGIN
   xlblposright=xsize-18
   xlblposleft=8
ENDELSE
; plot endpoint labels on GR x-sect panel, shadowed for readability, light over dark
XYOUTS, xlblposleft+1, 10+yoffleft, COLOR=0, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright+1, 10+yoffright, COLOR=0, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposleft, 11+yoffleft, COLOR=122, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright, 11+yoffright, COLOR=122, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2

; add data source/type and status annotations
XYOUTS, 15, (ysize-20), COLOR=122, $
    'GR volume-match samples, 1 dBZ resolution', $
    /DEVICE ;, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 15, (ysize-35)-yoff, COLOR=122, $
   'Max = '+gvmaxstr+' dBZ,  Mean Bright Band = '+bbstr+' km', /DEVICE
s2ku_txt = ''
IF N_ELEMENTS( s2ku ) EQ 1 THEN BEGIN
   if s2ku EQ 1 then s2ku_txt = ', Ku-adjusted'
   if s2ku EQ 0 then s2ku_txt = ', original S-band'
ENDIF
IF N_ELEMENTS( gvoff ) EQ 1 THEN BEGIN
   XYOUTS, 15, (ysize-50)-yoff, COLOR=122, "GR calibration offset = " + $
           STRING(gvoff, FORMAT='(i0)') + " dBZ" + s2ku_txt, /DEVICE
ENDIF

; plot bright band lines: middle, upper bound, lower bound
PLOTS, [0,xsize-1], [bb_y,bb_y], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr,bb_y_upr], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr,bb_y_lwr], /DEVICE, COLOR=0, LINESTYLE=1

IF no_data EQ 1 THEN XYOUTS, xsize/2-70, ysize/2, /DEVICE, COLOR=122, CHARSIZE=3, "NO ECHOES"

; -- PR panel next

IF N_ELEMENTS( caseTitle ) EQ 1 THEN $
   XYOUTS, 15, ysize*2-20-yoff, COLOR=122, caseTitle, /DEVICE

; plot endpoint labels on PR x-sect panel, shadowed for readability, light over dark
XYOUTS, xlblposleft+1, ysize+10+yoffleft, COLOR=0, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright+1, ysize+10+yoffright, COLOR=0, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposleft, ysize+11+yoffleft, COLOR=122, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright, ysize+11+yoffright, COLOR=122, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2

; add data source/type and status annotations
XYOUTS, 15, (ysize*2-20), COLOR=122, $
    sourceLabel+' volume-match samples, 1 dBZ resolution', $
    /DEVICE ;, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 15, (ysize*2-35)-yoff, COLOR=122, $
   'Max = '+prmaxstr+' dBZ,  Mean Bright Band = '+bbstr+' km', /DEVICE

IF KEYWORD_SET(difftext) THEN BEGIN
IF (countabv+countin+countbelow GT 0) THEN BEGIN
   xyouts, 15, (ysize*2-50)-yoff, COLOR=122, /DEVICE, $
     "PR-GR Mean Diff. Above / Within / Below BB :"
   xyouts, 95, (ysize*2-65)-yoff, COLOR=122, /DEVICE, $
    STRING(diffabove, FORMAT='(f0.2)') + ' / ' + STRING(diffin, FORMAT='(f0.2)') $
    +  ' / ' + STRING(diffbelow, FORMAT='(f0.2)')
ENDIF ELSE BEGIN
   IF countany GT 0 THEN BEGIN
      xyouts, 15, (ysize*2-50)-yoff, COLOR=122, /DEVICE, $
        "PR-GR Mean Diff. and No. of Samples, Unknown BB : "
      xyouts, 95, (ysize*2-65)-yoff, COLOR=122, /DEVICE, $
       "DIFF: " + STRING(diffany, FORMAT='(f0.2)') + ",  No. samples: " $
       + STRING(countany, FORMAT='(I0)')
   ENDIF ELSE xyouts, 15, (ysize*2-50)-yoff, COLOR=122, /DEVICE, $
        "PR-GR Mean Diff. : No qualifying samples"
ENDELSE
ENDIF

; plot bright band lines: middle, upper bound, lower bound
PLOTS, [0,xsize-1], [bb_y+ysize,bb_y+ysize], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr+ysize,bb_y_upr+ysize], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr+ysize,bb_y_lwr+ysize], /DEVICE, COLOR=0, LINESTYLE=1

; label the color bar
FOR i = 0, nbarsegs-1 DO BEGIN
   XYOUTS, xsize+30, colorbar_y + ystep*i - 4, labels[i], COLOR=122, /DEVICE
   XYOUTS, xsize+30, colorbar_y + ystep*i - 4 + ysize, labels[i], COLOR=122, /DEVICE
ENDFOR

; burn in a vertical scale on either side of the two x-sections
tickcolr = 0
FOR h = 1, 19 DO BEGIN
   xlen = 4
   yh = h*16-1
   IF h mod 5 EQ 0 THEN BEGIN
     ; plot major tick and label it with the height in km
      xlen = 7
      XYOUTS, xlen+6, yh-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+6, yh+ysize-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh+ysize-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
   ENDIF
   PLOTS, [xsize-xlen-1,xsize-1], [yh,yh], /DEVICE, COLOR=tickcolr  ; plot in black on right
   PLOTS, [xsize-xlen-1,xsize-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=122 ;COLOR=122        ; plot in white on right
   PLOTS, [0,xlen], [yh-1,yh-1], /DEVICE, COLOR= tickcolr           ; add a shadow to white plot
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=122          ; upper panel, left
   PLOTS, [0,xlen], [yh+ysize-1,yh+ysize-1], /DEVICE, COLOR= tickcolr  ; add a shadow
ENDFOR

IF no_data EQ 1 THEN XYOUTS, xsize/2-70, ysize+ysize/2, /DEVICE, COLOR=122, CHARSIZE=3, "NO ECHOES"

; grab the z-buffer content and free its memory
bufprgrout = TVRD()
DEVICE, /CLOSE

;-------------------------

; plot the difference image

;title = "PR-GR Volume Match Differences"
;WINDOW, 6, xsize=xwinsize, ysize=ysize, TITLE = title ;, ypos=50
SET_PLOT,'Z'
DEVICE, SET_RESOLUTION = [xwinsize,ysize]

; set up discrete colors
rgb24=[ $
[90,90,90],$      ;black
[255,255,255],$   ;white
[105,105,105],$   ;dim gray
[211,211,211],$   ;light gray
[255,20,147],$    ;deep pink
[255,105,180],$   ;hot pink
[255,192,203],$   ;pink
[255,0,0],$       ;red
[255,160,122],$   ;light salmon
[205,92,92],$     ;indian red
[139,0,0],$       ;dark red
[255,140,0],$     ;dark orange
[255,205,0],$     ;gold
[255,255,0],$     ;yellow
[255,255,255],$   ;white
[173,255,47],$    ;SpringGreen
[128,128,0],$     ;olive
[0,80,0],$        ;green
[0,139,139],$     ;dark cyan
[0,255,255],$     ;cyan
[65,105,225],$    ;royal blue
[0,0,255], $      ;blue
[153,50,204],$    ;dark orchid
[128,0,128],$     ;purple
[255,0,255] $     ;magenta
]

rr[0:24]=rgb24[0,*]
gg[0:24]=rgb24[1,*]
bb[0:24]=rgb24[2,*]

; define "Bill Olson" colors for +/- 7 dbz difference range, first overwriting
; colors defined by the preceding code block
rr[0:24]=100b
gg[0:24]=100b
bb[0:24]=100b

; just sample the compressed color table already loaded into array indices
; 129-255 as the colors for the diff image.  Make big steps through this table
; to get fairly discrete colors
for i = 8, 20 do begin
   bigstep = 129 + (i-8)*(128/(21-8))
   rr[i] = rr[bigstep]
   gg[i] = gg[bigstep]
   bb[i] = bb[bigstep]
endfor

; now set the maxdiff/mindiff/zerodiff special colors
rr[14]=255 & gg[14]=255 & bb[14]=255   ; white for 0 diff
rr[21]=255 & gg[21]=0   & bb[21]=255   ; magenta for >= 7 diff
rr[7]=123 & gg[7]=104 & bb[7]=238      ; medium slate blue for <= -7 diff

; set up unassigned/missing areas as gray
rr[230:250] = 100b ;128b ; made darker to split gray from olive green
gg[230:250] = 100b ;128b
bb[230:250] = 100b ;128b
; set 255 to white and 0 to black
rr[255] = 255b
gg[255] = 255b
bb[255] = 255b
rr[0] = 0b
gg[0] = 0b
bb[0] = 0b

; load resulting image to z-buffer
TV, diffimg2render

; add annotations to difference image

yoff = 0
IF N_ELEMENTS( caseTitle ) EQ 1 THEN BEGIN
   yoff = 15
   XYOUTS, 15, ysize-20-yoff, COLOR=122, caseTitle, /DEVICE
ENDIF

; plot the endpoint labels, shadowed for readability, light over dark
XYOUTS, xlblposleft+1, 10+yoffleft, COLOR=0, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright+1, 10+yoffright, COLOR=0, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposleft, 11+yoffleft, COLOR=122, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright, 11+yoffright, COLOR=122, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2

XYOUTS, 15, (ysize-20), COLOR=122, $
    'Volume match '+sourceLabelDiff+' - GR differences, 1 dBZ/color', $
    /DEVICE ;, CHARSIZE=1.5, CHARTHICK=2
IF N_ELEMENTS( gvoff ) EQ 1 THEN BEGIN
   XYOUTS, 15, (ysize-35)-yoff, COLOR=122, "GR calibration offset = " + $
           STRING(gvoff, FORMAT='(i0)') + " dBZ" + s2ku_txt, /DEVICE
ENDIF

; burn in a vertical scale on either side of the diff x-section
tickcolr = 0
FOR h = 1, 19 DO BEGIN
   xlen = 4
   yh = h*16-1
   IF h mod 5 EQ 0 THEN BEGIN
     ; plot major tick and label it with the height in km
      xlen = 7
      XYOUTS, xlen+6, yh-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+6, yh+ysize-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh+ysize-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
   ENDIF
   PLOTS, [xsize-xlen-1,xsize-1], [yh,yh], /DEVICE, COLOR=tickcolr  ; plot in black on right
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=122                   ; plot in white on left
   PLOTS, [0,xlen], [yh-1,yh-1], /DEVICE, COLOR= tickcolr           ; add a shadow to white plot
ENDFOR

; plot bright band lines: middle, upper bound, lower bound
PLOTS, [0,xsize-1], [bb_y,bb_y], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr,bb_y_upr], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr,bb_y_lwr], /DEVICE, COLOR=0, LINESTYLE=1

; label the color bar
;labels = ['-10','-9','-8','-7','-6','-5','-4','-3','-2','-1',' 0', $
;          ' 1',' 2',' 3',' 4',' 5', ' 6',' 7',' 8',' 9','10']
labels = ['-7','-6','-5','-4','-3','-2','-1',' 0', $
          ' 1',' 2',' 3',' 4',' 5', ' 6',' 7']
FOR i = 0, nlabelsdif-1 DO BEGIN
   XYOUTS, xsize+25, colorbar_ydif + 12*i + 3, labels[i], COLOR=122, /DEVICE, CHARSIZE=1
ENDFOR

IF no_data EQ 1 THEN XYOUTS, xsize/2-70, ysize/2, /DEVICE, COLOR=122, CHARSIZE=3, "NO ECHOES"

; grab the z-buffer content and free its memory
bufprgrdiffout = TVRD()
DEVICE, /CLOSE

;-------------------------

; define and fill the return structure holding the image buffers and metadata
thestruc = { $
   xs_prgr : xwinsize, $
   ys_prgr : ywinsize, $
   xs_diff : xwinsize, $
   ys_diff : ysize, $
   redct : rr, $
   grnct : gg, $
   bluct : bb, $
   prgr_xsect : bufprgrout, $
   diff_xsect : bufprgrdiffout, $
   no_data : no_data }

GOTO, OKexit

errorExit:
return, -1

OKexit:
return, thestruc

END
