;===============================================================================
;+
; Copyright Â© 2012, United States Government as represented by the
; Administrator for The National Aeronautics and Space Administration.
; All Rights Reserved.
;
; plot_pr_xsection_zbuf.pro    Morris/SAIC/GPM_GV    August 2012
;
; DESCRIPTION
; -----------
; Takes a full array of TRMM 2A-25 3-D reflectivity, parameters specifying the
; scan line and beginning and ending rays in the product for which a cross
; section of data is to be plotted, and bright band mean height and an optional
; plot title, and generates a pair of vertical cross sections of full-resolution
; PR reflectivity.  The top plot uses the coarse color table of the PPI plots
; with a 3 dBZ color binning, and the lower plot uses a 'smooth' IDL color table
; showing 1 dBZ color separation.  A parallax correction for the scan angle of
; the PR is applied to the height of each 250-m PR gate.
;
; The plots use a default value of 320 pixels in height for each of the two
; cross section plots, to match the dimensions of the plots of geometry-matched
; PR and GV data generated by the 'plot_geo_match_xsection' procedure.  The
; width of the cross-section plots, and of each plotted ray, varies according
; to the number of rays to be plotted in the normal mode of selecting one PR
; scan.  In the "automatic" mode of stepping through all the scans in the PR/GR
; overlap area, the window is sized for all 49 rays in the scan, a fixed width
; is assigned for each ray and the window, and rays are plotted in fixed
; locations as defined by their ray number in the scan.
;
; PARAMETERS
; ----------
; scanNumpr  - PR-product-relative number of the PR scan whose data are to be
;              plotted as a vertical cross section.  Zero-based array index.
; raystartpr - Starting ray of the scan to plot in the cross section.  Zero-
;              based array index into the full data array.
; rayendpr   - As above, but ending ray to plot in the cross section.
; z_data     - Full array of (assumed) 2A-25 3-D corrected reflectivity data.
; meanbb     - Mean height of the bright band, in km.
; scale      - Scale factor to be applied to convert z_data to dBZ units.
; rangeBinNums - Holds PR-analyzed bright band height, per ray
; caseTitle  - (Optional) title to be written into the cross section images.
; bbwidth    - Height (km) above/below the mean bright band height within
;              which a sample touching (above) [below] this layer is
;              considered to be within (above) [below] the BB.  If not
;              specified, takes on the default value (0.750) defined in
;              fprep_geo_match_profiles().
; startend2show - Optional parameter, a 2-element array listing the minimum
;                 starting and maximum ending ray numbers to be plotted in the
;                 cross section, over all PR scans in the data set.  Zero-based,
;                 values range from 0 to 48.  If provided, the ray widths and
;                 plotted ray locations in the cross sections are set up according
;                 to the number of rays between startend2show[0] and startend2show[1].
;                 In essence, the cross-section domain is set up in a fixed manner
;                 based on the this number of rays, where the plotted locations of
;                 each ray depends on the values of startend2show and raystartpr
;                 and rayendpr. 
; label_by_raynum - Optional binary parameter.  If set to OFF, then the edges of
;                   the x-sections are labeled with A and B, to orient the
;                   cross section with regard to the line drawn on the PPIs
;                   showing the location of the PR scan selected for display.
;                   IF set to ON, then the values of PR ray number contained in
;                   raystartpr and rayendpr are used to label the L/R edges of
;                   the x-section.
;
; HISTORY
; -------
; 07/2009  Morris/GPM GV/SAIC  
; - Changed coarse color steps to 3 dBZ to match the PPI color scale.  Fixed
;   labeling of same.
; 08/04/09  Morris/GPM GV/SAIC
; - Fixed the color assignments and color bar.
; 08/06/09  Morris/GPM GV/SAIC
; - Changed color bar logic to eliminate confusion.
; 04/22/10  Morris/GPM GV/SAIC
; - Added rangeBinNums parameter containing PR-analyzed bright band height, per
;   ray.  Added plotting of ray-specific BB height to the cross sections.
; - Changed plotting of bright band upper bound to 0.75 km (750 m) above meanbb.
; 05/11/10  Morris/GPM GV/SAIC
; - Disable plotting of ray-specific BB height (comment out).
; - Labeled windows with titles.
; 05/11/10  Morris/GPM GV/SAIC
; - Commented out diagnostic print statements for arzise and x and y sizes.
; 01/21/11  Morris/GPM GV/SAIC
; - Add BBBYRAY keyword option to enable/disable plot of ray-specific BB height
; 07/11/11  Morris/GPM GV/SAIC
; - Add MSL indication to mean BB height label.
; 02/06/12  Morris/GPM GV/SAIC
; - Commented out diagnostic print statement for BB_hgt.
; - Moved the 'A' and 'B' labels to bottoms of plots, and made them thicker
;   and in shadow text.
; - Added labeling of major height ticks on left of plot, and contrasting
;   color/pattern in ticks.
; 08/01/12  Morris/GPM GV/SAIC
; - Added BBWIDTH option to control plot of dotted lines indicating the
;   BB-affected region, rather than hard-coding of +/-750 m.
; 08/10/12  Morris/GPM GV/SAIC
; - Handled case where there is only one ray in the scan to be plotted, i.e.,
;   where raystartpr = rayendpr, which can come up in the new mode of automatic
;   incrementing of the PR scan.
; 08/14/12  Morris/GPM GV/SAIC
; - Changed background gray RGB to [92,92,92] for bottom panel to match the
;   background gray in the PPI colors and PR/GR cross sections.
;
; 08/15/12  Morris/GPM GV/SAIC
; - CREATED FROM plot_pr_xsection.pro.
; - Changed from a procedure to a function that returns a structure holding
;   the window size, the PR x-section images, and the combined PPI/smooth color
;   table.  Now plots to the Z-buffer rather than directly to display windows
;   to better support rapid updating of the x-section windows when sweeping
;   across the PR scans included in the matchup data set.
; - Added FIXEDRAYS parameter to position the cross section relative to a
;   full PR scan's worth of rays (49) rather than expanding the rays in the
;   PR/GR overlap to the window width.  That is, all rays have a fixed width
;   and position in the x-section plot, based on their ray number in the scan.
;   Even though we will have data for all 49 rays available to us from the 2A25
;   file data, we will still only plot those rays within the PR/GR overlap area.
; - Changed endpoint plotting in full-scan, fixed-width mode to plot starting and
;   ending ray number values at the ray location rather than at the far sides of
;   the plot window.
; - Changed the height ticks at the left side of the plots to white with a black
;   shadow for better visibility regardless of the background color.
; - Added a "NO ECHOES" indication for cross sections where no PR valid range
;   bins are present for plotted rays along the scan.
; 08/30/12  Morris/GPM GV/SAIC
; - Fixed plotting of BBByray height indicators for the FIXEDRAYS case and for
;   where the rangeBinNums value is 0 (top of ray = no BB).
; 09/07/12  Morris/GPM GV/SAIC
; - Added LABEL_BY_RAYNUM parameter to explicitly control the type of label
;   plotted at the endpoints of the cross section.
; - Shifted the plotted position of the right-edge label to the middle of that
;   ray.
; - Replaced FIXEDRAYS parameter with the STARTEND2SHOW parameter to define a
;   fixed domain for the cross section relative to a specific beginning and
;   ending ray rather than just relative to a full PR scan's worth of rays.
; -3/16/15  Morris/GPM GV/SAIC
; - Swapped plotted positions of caseTitle and data source/type annotations.
;
;
; EMAIL QUESTIONS OR COMMENTS TO:
;       <Bob Morris> kenneth.r.morris@nasa.gov
;       <Matt Schwaller> mathew.r.schwaller@nasa.gov
;-
;===============================================================================

function plot_pr_xsection_zbuf, scanNumpr, raystartpr, rayendpr, z_data, $
                                meanbb, scale, rangeBinNums, TITLE=caseTitle, $
                                BBBYRAY=BBbyray, BBWIDTH=bbwidth, $
                                STARTEND2SHOW=startend2show, $
                                LABEL_BY_RAYNUM=label_by_raynum

; "Include" file for PR-product-specific parameters (i.e., RAYSPERSCAN):
@pr_params.inc

IF ( N_ELEMENTS(bbwidth) NE 1 ) THEN bbwidth=0.750
IF bbwidth GT 2.0 OR bbwidth LT 0.2 THEN BEGIN
   print, "In plot_pr_xsections, overriding outlier bbwidth value:", $
           bbwidth, " km to 0.750 km"
   bbwidth=0.750
ENDIF

; compute the ray angle trig variables for parallax (only cos() used here):
cos_inc_angle = DBLARR(RAYSPERSCAN)
tan_inc_angle = DBLARR(RAYSPERSCAN)
cos_and_tan_of_pr_angle, cos_inc_angle, tan_inc_angle

; from the 2A25 Z array, extract the rays to be plotted for scan = scanNumpr
xsect2d = z_data[scanNumpr, raystartpr:rayendpr, *]
idxclutter = WHERE( xsect2d LT 0.0, nclutr )
IF ( nclutr GT 0 ) THEN xsect2d[idxclutter] = 0.0
xsect2d = xsect2d/scale  ; unscale PR dbz
; get rid of 1st (or 1st and 2nd) dimension(s) of size 1, and flip vertically
; to account for bin order (surface bin = 80)
trimmed = REFORM( xsect2d )
ts = SIZE(trimmed)
IF ts[0] EQ 2 THEN xsect2d = REVERSE( trimmed, 2 ) $  ; 2 or more rays to plot
ELSE xsect2d = REVERSE( trimmed, 1 )                  ; 1 ray to plot

IF (N_ELEMENTS(rangeBinNums) NE 0) THEN BEGIN
; Extract the 2-D range bin number of the bright band level from the 3-D array
;   and initialize a matching bright band height array FOR THIS SCAN/RAY SET
   BB_Bins = REFORM( rangeBinNums[scanNumpr, raystartpr:rayendpr,3] )
   BB_hgt = FLOAT(BB_Bins)
   BB_hgt[*] = BBHGT_UNDEFINED
  ; compute bright band height
   idxhavebb = WHERE ( BB_Bins LE 79 AND BB_Bins GT 0, counthavebb )
   IF (counthavebb GT 0) THEN BEGIN
      BB_hgt[idxhavebb] = $
         (79-BB_Bins[idxhavebb]) * (GATE_SPACE/1000.) * cos_inc_angle[raystartpr:rayendpr]
;      print, 'BB_hgt: ', BB_hgt
      BB_hgt[idxhavebb] = BB_hgt[idxhavebb]*16.  ; scale to image pixel y values
      have_bb=1
   ENDIF ELSE BEGIN
      BB_hgt[*] = BB_MISSING
      have_bb=0
   ENDELSE
ENDIF ELSE have_bb=0

; how many rays are we plotting this time?
IF ts[0] EQ 2 THEN BEGIN
  ; 2 or more rays to plot, have 2-D xsect2d array
   nrays = ts[1]
   nbins = ts[2]
ENDIF ELSE BEGIN
  ; only one ray to plot, have 1-D xsect2d array
   nrays = 1
   nbins = ts[1]
ENDELSE

ysize = (320/nbins)*nbins  ; we are trusting that nbins is fixed for 2A-25 rays

; set up the xsize and plotted width of each ray based on the domain to be used
label_by_raynum = KEYWORD_SET( label_by_raynum )

; figure out whether to configure ray width in x-sections based on the range of rays
; defined in startend2show, or on the number of PR/GR overlap rays in the current scan
CASE N_ELEMENTS(startend2show) OF
      0 : BEGIN
           ; just configure to do the number of rays in current scan (legacy plot)
            doFixed = 0
          END
      2 : BEGIN
           ; error check the values in startend2show
            IF startend2show[0] GT startend2show[1] THEN BEGIN
               doFixed = 0
               print, "In plot_pr_xsection, illegal value for STARTEND2SHOW ", $
                      "must be INTARR(2), with startend2show[0] LE startend2show[1]."
               print, "startend2show: ", startend2show
               goto, errorExit
            ENDIF ELSE BEGIN
               IF startend2show[0] LT 0 OR startend2show[1] GT 48 THEN BEGIN
                  doFixed = 0
                  print, "In plot_pr_xsection, illegal value for STARTEND2SHOW ", $
                         "must have startend2show[0] GE 0, and startend2show[1] LE 48."
                  print, "startend2show: ", startend2show
                  goto, errorExit
               ENDIF
            ENDELSE
           ; check that raystartpr, rayendpr values are between startend2show's
            IF (startend2show[0] LE raystartpr) AND (startend2show[1] GE rayendpr) THEN BEGIN
               doFixed = 1
            ENDIF ELSE BEGIN
               doFixed = 0
               print, "In plot_pr_xsection, values for raystartpr, rayendpr ", $
                      "exceed plot limits defined in startend2show."
               print, "startend2show: ", startend2show
               print, "raystartpr, rayendpr: ", raystartpr, rayendpr
               goto, errorExit
            ENDELSE
          END
   ELSE : BEGIN
            print, "In plot_pr_xsection, illegal value for STARTEND2SHOW, ", $
                   "must be either INTARR(2) or undefined.  Overriding to disabled."
            help, startend2show
            doFixed = 0
          END
ENDCASE

;PRINT, "" & PRINT, "doFixed: ", doFixed & PRINT, ""

IF doFixed THEN BEGIN
   nrayswide = startend2show[1]-startend2show[0]+1
   xsize = (ysize/nrayswide)*nrayswide
   raywidth = xsize/nrayswide
ENDIF ELSE BEGIN
   xsize = (ysize/nrays)*nrays
   raywidth = xsize/nrays
ENDELSE

; xoff: Where is the first ray plotted on the x-section window, x-wise?
IF doFixed THEN xoff = raywidth*(raystartpr-startend2show[0]) $
           ELSE xoff = 0  ; non-fixed-size window, legacy appearance

xwinsize = xsize + 50
ywinsize = ysize*2
image2render = BYTARR(xwinsize,ysize)  ; hold x-sect image plus color bar

; figure out how to label the ends of the cross section based on RAYSTARTEND presence/values
; -- initialize to legacy labels, then check RAYSTARTEND status for override
IF ( label_by_raynum ) THEN BEGIN
   leftlbl=STRING(raystartpr+1, FORMAT='(I0)')
   rightlbl=STRING(rayendpr+1, FORMAT='(I0)')
ENDIF ELSE BEGIN
   leftlbl = 'A'
   rightlbl = 'B'
ENDELSE

; set up the 16-level color table from the PPI as the bottom half of color table
; -- set values 122-127 as white, for labels and such
tvlct, rr,gg,bb,/get
rr[122:127] = 255
gg[122:127] = 255
bb[122:127] = 255
tvlct, rr,gg,bb

nsteps = 17      ; number of colors for our image
ystep = ysize/nsteps
ybarsize = ystep * nsteps
colorbar = BYTARR(15,ybarsize)
colorbar_y = (ysize-ybarsize)/2  ; y position of bottom of colorbar in image
; fill color bar values
FOR i = 0, nsteps-1 DO BEGIN
   colorbar[*,ystep*i:ystep*(i+1)-1] = i
ENDFOR

; put a white boundary around color bar
colorbar[*,0]=122 & colorbar[*,ybarsize-1]=122
colorbar[0,*]=122 & colorbar[14,*]=122

; burn color bar into image
image2render[xsize+10:xsize+10+15-1,colorbar_y:colorbar_y+ybarsize-1] = colorbar

; build the x-section as an image array --
; see geo_match/loadcolortable.pro for the dbz mapping to colors used below
maxprval = MAX(xsect2d)
maxprstr = STRING( maxprval, FORMAT='(f0.1)' )

xsectimg = BYTARR(xsize, ysize)
xsectimg[*,*] = 0b ;2B

for k = 0, nrays-1 DO BEGIN
   for l = 0, nbins - 1 DO BEGIN
     ; correct gate top/bottom height for beam parallax and fill image pixels
      xstart=k*raywidth + xoff
      xend = xstart + raywidth - 1
      ystart = FIX( l*4*cos_inc_angle[raystartpr+k] ) < 319
      yend = FIX( (l+1)*4*cos_inc_angle[raystartpr+k] ) < 319
     ; handle 2-D vs. 1-D data array
      IF ts[0] EQ 2 THEN $
         xsectimg[xstart:xend,ystart:yend] = BYTE( ( (xsect2d[k,l]-12.0 > 0)/3 +1)  < 128. ) $
      ELSE xsectimg[xstart:xend,ystart:yend] = BYTE( ( (xsect2d[l]-12.0 > 0)/3 +1)  < 128. )
   endfor
endfor

SET_PLOT,'Z'
; set up the z-buffer device, and set baseline character size to match up
; to how things would look if plotting directly to 'X' device, as 'Z'
; device has different pixels/cm scaling.  Little fuzzy on this, but it works.
DEVICE, SET_RESOLUTION = [xwinsize,ywinsize], SET_CHARACTER_SIZE=[6,10]

image2render[0,0] = xsectimg
; plot the PPI-colored x section in the top half of the window
TV, image2render, 0

; label the color bar
labels = ['BT','15','18','21','24','27','30','33','36','39','42','45','48','51','54','57']
FOR i = 0, nsteps-1 DO BEGIN
   IF i LT nsteps-1 THEN BEGIN
      XYOUTS, xsize+30, ysize+colorbar_y+ystep*(i+1)-4, labels[i], COLOR=122, /DEVICE
   ENDIF
ENDFOR

; get bright band level
bb_y = FIX(meanbb * 16.0)  ; assumes 4 pixels/gate, gate is 0.25 km deep
; assume BB is from +bbwidth km to -bbwidth km of meanbb, and compute upper/lower y-bounds
bb_y_upr = FIX( (meanbb+bbwidth) *16.0 )
bb_y_lwr = FIX( (meanbb-bbwidth) * 16.0 )
bbstr = STRING(meanbb, FORMAT='(f0.1)')

; plot bright band lines: middle, upper bound, lower bound
IF ( KEYWORD_SET(BBbyray) AND have_bb EQ 1 ) THEN BEGIN     ; plot the ray-specific bright band heights
   for k = 0, nrays-1 DO BEGIN
      xstart=k*raywidth + xoff
      xend = xstart + raywidth -1
      IF (BB_hgt[k] GT 0) THEN PLOTS, [xstart,xend], [BB_hgt[k]+ysize,BB_hgt[k]+ysize], $
                                     /DEVICE, COLOR=0, THICK=2
   endfor
ENDIF
PLOTS, [0,xsize-1], [bb_y+ysize,bb_y+ysize], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr+ysize,bb_y_upr+ysize], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr+ysize,bb_y_lwr+ysize], /DEVICE, COLOR=0, LINESTYLE=1

yoff = 0
IF N_ELEMENTS( caseTitle ) EQ 1 THEN BEGIN
   yoff = 15
   XYOUTS, 15, ysize+ysize-35-yoff, COLOR=122, caseTitle, /DEVICE
ENDIF

yoffleft=0 & yoffright=0  ; vertical offsets to be reset if labels overlap

IF doFixed THEN BEGIN
  ; compute position of ray labels, relative to where the rays are plotted, dealing
  ; with window bounds
   xlblposright = (((rayendpr-startend2show[0])*raywidth + raywidth/2) < (xsize-18)) > 6
   xlblposleft = ((raystartpr-startend2show[0])*raywidth > 6) < (xsize-18)
  ; deal with potential label overlaps
  IF xlblposright LE (xlblposleft+20) THEN BEGIN
      IF raystartpr GT 25 THEN BEGIN
         yoffleft = 15
         xlblposleft = xlblposleft < (xlblposright-6)
      ENDIF ELSE BEGIN
         xlblposright = xlblposright > (xlblposleft+6)
         yoffright = 15
      ENDELSE
   ENDIF
ENDIF ELSE BEGIN
   xlblposright=xsize-18
   xlblposleft=8
ENDELSE

; plot endpoint labels on upper x-sect panel, shadowed for readability, light over dark
XYOUTS, xlblposleft+1, ysize+10+yoffleft, COLOR=0, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright+1, ysize+10+yoffright, COLOR=0, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposleft, ysize+11+yoffleft, COLOR=122, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright, ysize+11+yoffright, COLOR=122, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2

XYOUTS, 15, ysize+(ysize-20), COLOR=122, $
        'Original PR gates, using PPI color scale', /DEVICE
XYOUTS, 15, ysize+(ysize-20)-yoff, COLOR=122, '(3 dBZ steps)', /DEVICE
XYOUTS, 15, ysize+(ysize-50)-yoff, COLOR=122, $
   'Max = '+maxprstr+' dBZ,  Mean Bright Band = '+bbstr+' km MSL', /DEVICE

; do another x-section, using more colors and more resolution of dBZ values
; -- render in image values 128-255, using another color table
image2render[*,*] = 0B

; build a 1-dbz-resolution color bar
; 1. we do plot the first label (BT)
; 2. we label the bottom of each segment, starting with labels[0] at bottom
;    of bar and ending with last label at bottom of last segment
; 3. we will have this many "segments" in color bar:

       nbarsegs = N_ELEMENTS(labels)

; 4. dbz range of colorbar goes beyond value of last label by one label step (3dBZ):

       zperseg = (FIX(labels[nbarsegs-1])-FIX(labels[nbarsegs-2]))
       zmaxonbar = FIX(labels[nbarsegs-1]) + zperseg
       zminonbar = FIX(labels[1])
       zrange = zmaxonbar-zminonbar

;    we extend the dbz range by one segment to account for the 'below threshold'
;    segment and see how many dbz values we need to show in the total bar length
 
       zrangeext = zrange+zperseg

; 5. we fill the lowest segment with fixed color value for BT (below threshold, < 15dBZ)
; 6. the remaining nbarsegs-1 segments have 127 colors available to be assigned
; 7. increment over the 127 color table colors in (near) equal jumps, when color is
;    associated to next whole dBZ, using the full color range from 129-255

       colorStepPerdbz = 127.0/zrange

; 9. assign an equal number of y-pixels to each dbz (color) within the vertical
;    bounds of the window.  Leave some space above/below bar.

       pixPerColor = (ysize-20)/zrangeext  ; (don't use full image extent for bar)

;    preceding 2 variables are rounded ints, for sizing the bar in the window
;    - the following variables are actual sizes/increments

       ybarsize = pixPerColor * zrangeext + 2  ; (add 2 pixels for bar borders)

; 10. label position y-increment, and color bar "breakpoints":
       ystep = pixPerColor * zPerSeg

; 11. hold colors for all whole dbz from zminonbar to zmaxonbar, plus BT color value:

       color4dbz = BYTARR(zrange+1) 
       color4dbz[*] = 128

; 12. assign bar array and fill color bar values
       colorbar = BYTARR(15,ybarsize)
       colorbar_y = (ysize-ybarsize)/2  ; y position of bottom of colorbar in image

;     do the BT segment first, assign image count 128 to it. Skip the 0th y-pos.
       colorbar[*,1:ystep] = 128

;     do the color bar colors (also image counts) by 1 dBZ steps
       dbzlast = 0
       colorlast = 129
       color4dbz[dbzlast+1] = colorlast
       for i = ystep+1, ybarsize-2 do begin
          if ( (i-1) MOD ystep EQ 0 ) THEN BEGIN
             colorbar[*,i] = 128  ; mark every segment boundary (labeled dBZ location)
          endif else begin
            ; assign a new color if next whole dbz
             thisdbz = FIX( (i-1-ystep)/pixpercolor )
             IF ( thisdbz GT dbzlast ) THEN BEGIN
                dbzlast = thisdbz
                colorlast = FIX( 129 + thisdbz*colorStepPerdbz )
                color4dbz[dbzlast+1] = colorlast
             ENDIF
             colorbar[*,i] = colorlast
;print, 'i: ',i,', dbzlast: ',dbzlast,', colorlast: ',colorlast
         endelse
       endfor

;print, 'max i: ', i-1, ', assigned color: ', colorbar[0,i-1],', colorStepPerdBZ: ', colorStepPerdbz
;print, 'color4dbz: ', color4dbz

; put a white boundary around color bar
colorbar[*,0]=122 & colorbar[*,ybarsize-1]=122
colorbar[0,*]=122 & colorbar[14,*]=122

; burn color bar into image
image2render[xsize+10:xsize+10+15-1,colorbar_y:colorbar_y+ybarsize-1] = colorbar

; load compressed color table 33 into LUT values 129-255
loadct, 33, /SILENT
tvlct, rrhi, gghi, bbhi, /get
FOR j = 1,127 DO BEGIN
   rr[j+128] = rrhi[j*2]
   gg[j+128] = gghi[j*2]
   bb[j+128] = bbhi[j*2]
ENDFOR
; 128 is background color (gray 92) for Below Threshold (see DZ in loadcolortable.pro)
rr[128] = 92 & gg[128] = 92 & bb[128]=92
tvlct, rr,gg,bb

; load the image array with PR gate values

xsectimg[*,*] = 0b         ; re-init image array. now using upper half of byte
for k = 0, nrays-1 DO BEGIN
   for l = 0, nbins - 1 DO BEGIN
     ; correct gate top/bottom height for beam parallax and fill image pixels
      xstart=k*raywidth + xoff
      xend = xstart + raywidth - 1
      ystart = FIX( l*4*cos_inc_angle[raystartpr+k] ) < 319
      yend = FIX( (l+1)*4*cos_inc_angle[raystartpr+k] ) < 319
     ; -- every 1 dBZ in reflectivity increments by colorStepPerdbz image counts,
     ;    starting from a bottom cutoff of 15.0 dBZ at image count of 129
     ; round off the dbz value and look up the assigned image color for the dbz
     ; -- handle 2-D vs. 1-D data array
      IF ts[0] EQ 2 THEN $
         coloridx4gate = (FIX(xsect2d[k,l]-(zminonbar-1)) > 0) < zrange $
      ELSE coloridx4gate = (FIX(xsect2d[l]-(zminonbar-1)) > 0) < zrange
      xsectimg[xstart:xend,ystart:yend] = color4dbz[coloridx4gate]
   endfor
endfor
image2render[0,0] = xsectimg
; insert a separator at the top of the lower image
image2render[*,ysize-2:ysize-1] = 122B
TV, image2render, 1

; plot endpoint labels on lower x-sect panel, shadowed for readability, light over dark
XYOUTS, xlblposleft+1, 10+yoffleft, COLOR=0, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright+1, 10+yoffright, COLOR=0, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposleft, 11+yoffleft, COLOR=122, leftlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, xlblposright, 11+yoffright, COLOR=122, rightlbl, /DEVICE, CHARSIZE=1.5, CHARTHICK=2

IF N_ELEMENTS( caseTitle ) EQ 1 THEN $
   XYOUTS, 15, ysize-20-yoff, COLOR=122, caseTitle, /DEVICE
XYOUTS, 15, (ysize-20), COLOR=122, 'Original PR gates, with 1 dBZ resolution', $
        /DEVICE ;, CHARSIZE=1.5, CHARTHICK=2
XYOUTS, 15, (ysize-35)-yoff, COLOR=122, $
   'Max = '+maxprstr+' dBZ,  Mean Bright Band = '+bbstr+' km MSL', /DEVICE

; plot bright band lines: middle, upper bound, lower bound
IF ( KEYWORD_SET(BBbyray) AND have_bb EQ 1 ) THEN BEGIN     ; plot the ray-specific bright band heights
   for k = 0, nrays-1 DO BEGIN
      xstart=k*raywidth + xoff
      xend = xstart + raywidth -1
      IF (BB_hgt[k] GT 0) THEN PLOTS, [xstart,xend], [BB_hgt[k],BB_hgt[k]], $
                                     /DEVICE, COLOR=122, THICK=2
   endfor
ENDIF
PLOTS, [0,xsize-1], [bb_y,bb_y], /DEVICE, COLOR=0, THICK=2, LINESTYLE=2
PLOTS, [0,xsize-1], [bb_y_upr,bb_y_upr], /DEVICE, COLOR=0, LINESTYLE=1
PLOTS, [0,xsize-1], [bb_y_lwr,bb_y_lwr], /DEVICE, COLOR=0, LINESTYLE=1

; label lower image's color bar
FOR i = 0, nbarsegs-1 DO BEGIN
   XYOUTS, xsize+30, colorbar_y + ystep*i - 3, labels[i], COLOR=122, /DEVICE
ENDFOR

; burn in a vertical scale on either side of the two x-sections
tickcolr = 0
FOR h = 1, 19 DO BEGIN
   xlen = 4
   yh = h*16-1
   IF h mod 5 EQ 0 THEN BEGIN
     ; plot major tick and label it with the height in km
      xlen = 7
      XYOUTS, xlen+6, yh-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+6, yh+ysize-3, COLOR=tickcolr, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
      XYOUTS, xlen+5, yh+ysize-2, COLOR=122, string(h, FORMAT='(I0)')+" km", /DEVICE, CHARSIZE=0.75
   ENDIF
   PLOTS, [xsize-xlen-1,xsize-1], [yh,yh], /DEVICE, COLOR=tickcolr  ; plot in black on right
   PLOTS, [xsize-xlen-1,xsize-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=tickcolr
   PLOTS, [0,xlen-1], [yh,yh], /DEVICE, COLOR=122 ;COLOR=122        ; plot in white on right
   PLOTS, [0,xlen], [yh-1,yh-1], /DEVICE, COLOR= tickcolr           ; add a shadow to white plot
   PLOTS, [0,xlen-1], [yh+ysize,yh+ysize], /DEVICE, COLOR=122          ; upper panel, left
   PLOTS, [0,xlen], [yh+ysize-1,yh+ysize-1], /DEVICE, COLOR= tickcolr  ; add a shadow
ENDFOR

; grab the z-buffer content and free its memory
bufpr2out = TVRD()
DEVICE, /CLOSE

;-------------------------

; define and fill the return structure holding the image buffers and metadata
thestruc = { $
   xs_pr2 : xwinsize, $
   ys_pr2 : ywinsize, $
   redct : rr, $
   grnct : gg, $
   bluct : bb, $
   pr2_xsect : bufpr2out }

GOTO, OKexit

errorExit:
return, -1

OKexit:
return, thestruc
end
